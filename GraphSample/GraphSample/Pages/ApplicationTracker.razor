@page "/applicationtracker"
@using System.Security.Authentication
@using Microsoft.Graph
@using Microsoft.Graph.Models
@using TimeZoneConverter
@using SharedModels.Models
@using Microsoft.Fast.Components.FluentUI
@using Microsoft.AspNetCore.Components.Web

@using GraphSample.ReusableComponents


@inject GraphSample.Services.IBackendApiService backendApiService
@inject GraphSample.Graph.GraphClientFactory clientFactory

<AuthorizeView>
    <Authorized>
        <h1 class="mb-3">Application Dashboard</h1>
        @if (fetchingTimelines)
        {
            <FluentProgressRing></FluentProgressRing>
        }
        else
        {
        <div class="container">
            <div class="main-div">
                <table class="table">
                    <thead>
                        <tr>
                            <th></th>
                            <th>Comapny</th>
                            <th>Role</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var timeline in timelines)
                        {
                            <tr height="2.5em">
                                @if (emailsShowing && emailsShowingTimeline == timeline.timelineID)
                                {
                                    <td><button class="fixed-height-row button " @onclick="() => emailsShowing = false">Hide emails</button></td>
                                }
                                else
                                {
                                    <td><button class="fixed-height-row button " @onclick="() => ShowEmails(timeline)">Show emails</button></td>
                                }
                                <td><div class="company-content">@timeline.company</div></td>
                                <td><div class="role-content">@timeline.role</div></td>
                                <td>@timeline.hasUnreadEmails</td>
                            </tr>
                        }
                        <button class="btn btn-primary" @onclick="() => ShowAddTimelineModal()">Add Timeline</button>
                    </tbody>
                </table>
            </div>
            <div class="main-div">
                @if (!emailsShowing)
                {
                    <table class="table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>
                                    Associated emails
                                </th>
                                <th></th>
                                <th>Assessments</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var timeline in timelines)
                            {
                                <tr height="2.5em">
                                    <td> <span class="add-button" @onclick="() => ShowModal(timeline.timelineID)">+</span></td>
                                    <td>
                                        <div class="email-container">
                                            @foreach (var email in timeline.associatedEmailAddresses)
                                            {
                                                <div class="email">@email</div>
                                                <span class="remove-button" @onclick="() => RemoveEmail(email, timeline.timelineID)">x</span>
                                            }
                                        </div>
                                    </td>
                                    <td> <span class="add-button" @onclick="() => ShowAssessmentModal(timeline.timelineID)">+</span></td>
                                    <td>
                                        <div style="display: flex; overflow-x: auto;">
                                            @foreach (var assessment in timeline.assessments)
                                            {
                                                <div style="min-width: 200px;">@((assessment.type != AssessmentType.Custom) ? assessment.type : assessment.customDescription)</div><br />
                                                <div style="min-width: 200px;">@assessment.date</div>
                                                <span class="remove-button" @onclick="() => RemoveAssessment(assessment, timeline.timelineID)">x</span>
                                            }
                                        </div>
                                    </td>
                                    <td><button class="btn btn-primary red-button" @onclick="() => ShowRemoveTimelineModal(timeline.timelineID)">Delete</button></td>
                                </tr>
                            }
                        </tbody>
                    </table>
                }
                else
                {
                    @if (fetchingEmails)
                    {
                        <FluentProgressRing></FluentProgressRing>
                    }
                    else
                    {
                        <table>
                            <thead>
                                <tr>
                                    <th>Sender</th>
                                    <th>Sent Time</th>
                                    <th>Subject</th>
                                    <th>Body</th>
                                    <th>Unread</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var email in selectedAssociatedEmails)
                                {
                                    <tr>
                                        <td>@email.Item2.Sender.EmailAddress.Address</td>
                                        <td>@email.Item2.ReceivedDateTime</td>
                                        <td>@email.Item2.Subject</td>
                                        <td>@(new MarkupString(email.Item2.Body.Content))</td>
                                        <td>@email.Item1</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    }
                }
            </div>
        </div>
        }
    </Authorized>
    <NotAuthorized>
        <RedirectToLogin />
    </NotAuthorized>
</AuthorizeView>

<style>
    .email-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        height: 75px;
        overflow-y: scroll;
    }

    .add-button {
        margin-right: 0.5em;
        cursor: pointer;
        color: green;
    }

    .remove-button {
        cursor: pointer;
        color: red;
        margin-left: 0.5em;
    }

    .red-button {
        background-color: red;
        color: white;
    }
    .container {
        display: flex;
        align-items: stretch; 
    }

    .main-div {
        flex: 1; 
    }

    .company-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        overflow-y: scroll;
    }
    .role-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        width: 150px;
        overflow-y: scroll;
    }


    .fixed-height-row button {
        position: sticky;
        top: 0;
    }
</style>

@code {
    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }

    private GraphServiceClient? graphClient;
    private string? dateTimeFormat;
    private string userTimeZone = string.Empty;
    private List<ApplicationTimeline> timelines;
    private bool emailsShowing;
    private int emailsShowingTimeline;
    //private List<Message>? selectedAssociatedEmails;
    private List<Tuple<bool, Message>> selectedAssociatedEmails;
    private bool fetchingEmails;
    private bool fetchingTimelines;

    protected override async Task OnInitializedAsync()

    {
        if (authenticationStateTask == null)
        {
            throw new AuthenticationException(
                "Unable to access authentication state");
        }

        // Get the user's time zone
        var user = (await authenticationStateTask).User;
        var graphTimeZone = user.GetUserGraphTimeZone();
        dateTimeFormat = $"{user.GetUserGraphDateFormat()} {user.GetUserGraphTimeFormat()}";

        // Calculate the start and end of the current week in user's time zone
        var startOfWeek = GetUtcStartOfWeekInTimeZone(DateTime.Today, graphTimeZone);
        var endOfWeek = startOfWeek.AddDays(7);

        graphClient = clientFactory.GetAuthenticatedClient();
        emailsShowing = false;

        fetchingTimelines = true;

        timelines = await backendApiService.getUserTimelinesAsync("ks2220");//user?.Identity?.Name);

        //experimental
        List<Message> allAssociatedEmails = new();
        List<string> allAssociatedEmailStrings = new();
        Dictionary<string, int> emailCounts = new Dictionary<string, int>();
        foreach (var currentAssociatedEmails in timelines.Select(t => t.associatedEmailAddresses))
        {
            foreach (var email in currentAssociatedEmails)
            {
                allAssociatedEmailStrings.Add(email);
            }
        }

        var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
        var filter = string.Join(" or ", emailFilters);

        var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
        {
            requestConfiguration.QueryParameters.Filter = filter;
        });

        //if (result != null)
        //{

        //    foreach (var email in allAssociatedEmailStrings)
        //    {
        //        int count = result.Value.Count(msg => msg.Sender.EmailAddress.Address == email);
        //        emailCounts[email] = count;
        //    }
        //}
        //foreach (var timeline in timelines)
        //{
        //    int totalCount = 0;
        //    foreach (var email in timeline.associatedEmailAddresses) { totalCount += emailCounts[email]; }
        //    if (totalCount != timeline.readEmailCount) { timeline.hasUnreadEmails = true; }
        //}

        var groupedIds = result.Value.GroupBy(msg => msg.Sender.EmailAddress.Address).
            ToDictionary(group => group.Key, group => group.ToList());

        for (int i = 0; i < timelines.Count(); i++)
        {
            var timeline = timelines[i];
            bool loopFlag = false;
            foreach (var email in timeline.associatedEmailAddresses)
            {
                if (loopFlag) { break; }
                if (groupedIds.ContainsKey(email))
                {
                    var messages = groupedIds[email];
                    foreach (var msg in messages)
                    {
                        if (!timeline.readEmails.ContainsKey(msg.Id))
                        {
                            timelines[i].hasUnreadEmails = true;
                            loopFlag = true;
                            break;
                        }
                    }
                }
            }
        }



        fetchingTimelines = false;

        //experimental
    }
    public async void ShowEmails(ApplicationTimeline timeline)
    {
        emailsShowing = true;
        emailsShowingTimeline = timeline.timelineID;
        await GetAssociatedEmails(timeline);
    }

    public async Task GetAssociatedEmails(ApplicationTimeline timeline)
    {
        fetchingEmails = true;
        //List<Message>? fetchedEmails = new();
        List<Tuple<bool, Message>> fetchedEmails = new();
        foreach (var email in timeline.associatedEmailAddresses)
        {
            var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
            {
                requestConfiguration.QueryParameters.Filter = $"from/emailAddress/address eq '{email}'";
            });
            if (result != null)
            {
                //fetchedEmails.AddRange(result.Value);
                foreach (var msg in result.Value)
                {
                    if (!timeline.readEmails.ContainsKey(msg.Id))
                    {
                        fetchedEmails.Add(new Tuple<bool, Message>(true, msg));
                        timeline.readEmails[msg.Id] = true;
                    }
                    else
                    {
                        fetchedEmails.Add(new Tuple<bool, Message>(false, msg));
                    }
                }
            }
        }

        //selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.ReceivedDateTime).ToList();
        selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.Item2.ReceivedDateTime).ToList();


        //bool setSuccess = await backendApiService.updateReadEmails("ks2220", timeline.timelineID, fetchedEmails.Count());
        //if (setSuccess)
        //{
        //    timeline.hasUnreadEmails = false;
        //    timeline.readEmailCount = fetchedEmails.Count();
        //}
        ReadEmailsBson readEmailsBson = new ReadEmailsBson
        { readEmails = timeline.readEmails,
            timelineID = timeline.timelineID };
        var response = await backendApiService.updateReadEmailsDict("ks2220", readEmailsBson);

        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync("ks2220", timeline.timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timeline.timelineID);
            if (index != -1)
            {
                timelines[index] = newTimeline;
            }
        }

        fetchingEmails = false;
        StateHasChanged();
    }

    public async void RemoveEmail(string email, int timelineID)
    {
        var response = await backendApiService.removeEmail(email, "ks2220", timelineID);

        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync("ks2220", timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            if (index != -1)
            {
                timelines[index] = newTimeline;
                StateHasChanged();
            }
        }

    }

    public async void RemoveAssessment(Assessment assessment, int timelineID)
    {
        var response = await backendApiService.removeAssessment(assessment, "ks2220", timelineID);

        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync("ks2220", timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            if (index != -1)
            {
                timelines[index] = newTimeline;
                StateHasChanged();
            }
        }

    }

    [CascadingParameter] IModalService ModalInputPopup { get; set; } = default!;

    private async Task ShowModal(int timelineID)
    {
        var inputPopupModal = ModalInputPopup.Show<InputPopup>();
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            string newEmail = result.Data?.ToString();
            if (newEmail != "")
            {
                var response = await backendApiService.addEmail(newEmail, "ks2220", timelineID);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync("ks2220", timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowAddTimelineModal()
    {
        var inputPopupModal = ModalInputPopup.Show<AddTimelinePopup>();
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            TimelineBson? newTimelineBson = result.Data as TimelineBson;
            if (newTimelineBson != null)
            {
                int newTimelineID = await backendApiService.addTimeline("ks2220", newTimelineBson);
                if (newTimelineID != -1)
                {
                    try
                    {
                        ApplicationTimeline newTimeline = await backendApiService.getUserTimelineAsync("ks2220", newTimelineID);
                        timelines.Add(newTimeline);
                        StateHasChanged();
                    }
                    catch
                    {
                        ;
                    }
                }

            }

        }
    }

    private async Task ShowAssessmentModal(int timelineID)
    {
        var assessmentModal = ModalInputPopup.Show<AssessmentInputPopup>();
        var result = await assessmentModal.Result;

        if (result.Confirmed)
        {
            Assessment? newAssessment = result.Data as Assessment;
            if (newAssessment != null)
            {
                var response = await backendApiService.addAssessment(newAssessment, "ks2220", timelineID);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync("ks2220", timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowRemoveTimelineModal(int timelineID)
    {
        var removeTimelinePopup = ModalInputPopup.Show<RemoveTimelinePopup>();
        var result = await removeTimelinePopup.Result;

        if (result.Confirmed)
        {
            var response = await backendApiService.removeTimeline("ks2220", timelineID);
            if (response)
            {
                timelines = await backendApiService.getUserTimelinesAsync("ks2220");
                StateHasChanged();
            }
        }
    }

    private DateTime GetUtcStartOfWeekInTimeZone(DateTime today, string timeZoneId)
    {
        // Time zone returned by Graph could be Windows or IANA style
        // TimeZoneConverter can take either
        TimeZoneInfo userTimeZone = TZConvert.GetTimeZoneInfo(timeZoneId);

        // Assumes Sunday as first day of week
        int diff = System.DayOfWeek.Sunday - today.DayOfWeek;

        // create date as unspecified kind
        var unspecifiedStart = DateTime.SpecifyKind(today.AddDays(diff), DateTimeKind.Unspecified);

        // convert to UTC
        return TimeZoneInfo.ConvertTimeToUtc(unspecifiedStart, userTimeZone);
    }

    private string FormatIso8601DateTime(string? iso8601DateTime)
    {
        if (string.IsNullOrEmpty(iso8601DateTime))
        {
            return string.Empty;
        }

        // Load into a DateTime
        var dateTime = DateTime.Parse(iso8601DateTime);

        if (!string.IsNullOrWhiteSpace(dateTimeFormat))
        {
            // Format it using the user's settings
            return dateTime.ToString(dateTimeFormat);
        }

        // Fallback to return original value
        return iso8601DateTime;
    }


    }

