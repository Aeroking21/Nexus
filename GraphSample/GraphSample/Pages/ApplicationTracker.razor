@page "/applicationtracker"
@using System.Security.Authentication
@using Microsoft.Graph
@using Microsoft.Graph.Models
@using TimeZoneConverter
@using SharedModels.Models
@using GraphSample.ReusableComponents


@inject GraphSample.Services.IBackendApiService backendApiService
@inject GraphSample.Graph.GraphClientFactory clientFactory

<AuthorizeView>
    <Authorized>
        <h1 class="mb-3">Application Dashboard</h1>
        @if (fetchingTimelines || creatingApplicant)
        {
            <FluentProgressRing></FluentProgressRing>
        }
        else if (!isRegistered)
        {
            <button class="btn btn-primary" @onclick="() => CreateApplicant()">Start Your Application Journey Now!</button>
        }
        else
        {
            <div class="container">
                <div class="main-div">
                    <table class="table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Comapny</th>
                                <th>Role</th>
                                <th></th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var timeline in timelines)
                            {
                                <tr height="2.5em">
                                    @if (emailsShowing && emailsShowingTimeline == timeline.timelineID)
                                    {
                                        <td><button class="fixed-height-row button " @onclick="() => emailsShowing = false">Hide emails</button></td>
                                    }
                                    else
                                    {
                                        <td><button class="fixed-height-row button " @onclick="() => ShowEmails(timeline)">Show emails</button></td>
                                    }
                                    <td><div class="company-content">@timeline.company</div></td>
                                    <td><div class="role-content">@timeline.role</div></td>
                                    <td>@timeline.hasUnreadEmails</td>
                                </tr>
                            }
                            <button class="btn btn-primary" @onclick="() => ShowAddTimelineModal()">Add Timeline</button>
                        </tbody>
                    </table>
                </div>
                <div class="main-div">
                    @if (!emailsShowing)
                    {
                        <table class="table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>
                                        Associated emails
                                    </th>
                                    <th></th>
                                    <th>Assessments</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var timeline in timelines)
                                {
                                    <tr height="2.5em">
                                        <td> <span class="add-button" @onclick="() => ShowModal(timeline.timelineID)">+</span></td>
                                        <td>
                                            <div class="email-container">
                                                @foreach (var email in timeline.associatedEmailAddresses)
                                                {
                                                    <div class="email">@email</div>
                                                    <span class="remove-button" @onclick="() => RemoveEmail(email, timeline.timelineID)">x</span>
                                                }
                                            </div>
                                        </td>
                                        <td> <span class="add-button" @onclick="() => ShowAssessmentModal(timeline.timelineID)">+</span></td>
                                        <td>
                                            <div style="display: flex; overflow-x: auto;">
                                                @foreach (var assessment in timeline.assessments)
                                                {
                                                    <div style="min-width: 200px;">@((assessment.type != AssessmentType.Custom) ? assessment.type : assessment.customDescription)</div><br />
                                                    <div style="min-width: 200px;">@assessment.date</div>
                                                    <span class="remove-button" @onclick="() => RemoveAssessment(assessment, timeline.timelineID)">x</span>
                                                }
                                            </div>
                                        </td>
                                        <td><button class="btn btn-primary red-button" @onclick="() => ShowRemoveTimelineModal(timeline.timelineID)">Delete</button></td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    }
                    else
                    {
                        @if (fetchingEmails)
                        {
                            <FluentProgressRing></FluentProgressRing>
                        }
                        else
                        {
                            <table>
                                <thead>
                                    <tr>
                                        <th>Sender</th>
                                        <th>Sent Time</th>
                                        <th>Subject</th>
                                        <th>Body</th>
                                        <th>Unread</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    @foreach (var email in selectedAssociatedEmails)
                                    {
                                        <tr>
                                            <td>@email.Sender.EmailAddress.Address</td>
                                            <td>@email.ReceivedDateTime</td>
                                            <td>@email.Subject</td>
                                            <td>@(new MarkupString(email.Body.Content))</td>
                                            <td>@email.IsRead</td>
                                        </tr>
                                    }
                                </tbody>
                            </table>
                        }
                    }
                </div>
            </div>
        }
    </Authorized>
    <NotAuthorized>
        <RedirectToLogin />
    </NotAuthorized>
</AuthorizeView>

<style>
    .email-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        height: 75px;
        overflow-y: scroll;
    }

    .add-button {
        margin-right: 0.5em;
        cursor: pointer;
        color: green;
    }

    .remove-button {
        cursor: pointer;
        color: red;
        margin-left: 0.5em;
    }

    .red-button {
        background-color: red;
        color: white;
    }
    .container {
        display: flex;
        align-items: stretch; 
    }

    .main-div {
        flex: 1; 
    }

    .company-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        overflow-y: scroll;
    }
    .role-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        width: 150px;
        overflow-y: scroll;
    }


    .fixed-height-row button {
        position: sticky;
        top: 0;
    }
</style>

@code {
    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }

    private GraphServiceClient? graphClient;
    private string? dateTimeFormat;
    private string userTimeZone = string.Empty;
    private List<ApplicationTimeline>? timelines;
    private bool emailsShowing;
    private int emailsShowingTimeline;
    //private List<Message>? selectedAssociatedEmails;
    private List<Message> selectedAssociatedEmails;
    private bool fetchingEmails = false;
    private bool fetchingTimelines = false;
    private bool creatingApplicant = false;
    private string Username;
    private bool isRegistered;

    protected override async Task OnInitializedAsync()

    {
        if (authenticationStateTask == null)
        {
            throw new AuthenticationException(
                "Unable to access authentication state");
        }

        // Get the user's time zone
        var user = (await authenticationStateTask).User;
        Username = user.Identity?.Name;
        var graphTimeZone = user.GetUserGraphTimeZone();
        dateTimeFormat = $"{user.GetUserGraphDateFormat()} {user.GetUserGraphTimeFormat()}";
        // Calculate the start and end of the current week in user's time zone
        var startOfWeek = GetUtcStartOfWeekInTimeZone(DateTime.Today, graphTimeZone);
        var endOfWeek = startOfWeek.AddDays(7);

        graphClient = clientFactory.GetAuthenticatedClient();
        emailsShowing = false;
        fetchingTimelines = true;
        timelines = await backendApiService.getUserTimelinesAsync(Username);

        if (timelines != null)
        {

            //experimental
            isRegistered = true;
            List<Message> allAssociatedEmails = new();
            List<string> allAssociatedEmailStrings = new();
            //Dictionary<string, int> emailCounts = new Dictionary<string, int>();
            foreach (var currentAssociatedEmails in timelines.Select(t => t.associatedEmailAddresses))
            {
                foreach (var email in currentAssociatedEmails)
                {
                    allAssociatedEmailStrings.Add(email);
                }
            }

            var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
            var filter = string.Join(" or ", emailFilters);

            var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
            {
                requestConfiguration.QueryParameters.Filter = filter;
            });

            //if (result != null)
            //{

            //    foreach (var email in allAssociatedEmailStrings)
            //    {
            //        int count = result.Value.Count(msg => msg.Sender.EmailAddress.Address == email);
            //        emailCounts[email] = count;
            //    }
            //}
            //foreach (var timeline in timelines)
            //{
            //    int totalCount = 0;
            //    foreach (var email in timeline.associatedEmailAddresses) { totalCount += emailCounts[email]; }
            //    if (totalCount != timeline.readEmailCount) { timeline.hasUnreadEmails = true; }
            //}

            var groupedEmails = result.Value.GroupBy(msg => msg.Sender.EmailAddress.Address).
                ToDictionary(group => group.Key, group => group.ToList());

            for (int i = 0; i < timelines.Count(); i++)
            {
                var timeline = timelines[i];
                bool loopFlag = false;
                foreach (var email in timeline.associatedEmailAddresses)
                {
                    if (loopFlag) { break; }
                    if (groupedEmails.ContainsKey(email))
                    {
                        var messages = groupedEmails[email];
                        foreach (var msg in messages)
                        {
                            if (msg.IsRead == false)
                            {
                                timelines[i].hasUnreadEmails = true;
                                loopFlag = true;
                                break;
                            }
                        }
                    }
                }
            }



            fetchingTimelines = false;
        }
        else
        {
            isRegistered = false;
        }

        fetchingTimelines = false;

    }
    public async void ShowEmails(ApplicationTimeline timeline)
    {
        emailsShowing = true;
        emailsShowingTimeline = timeline.timelineID;
        await GetAssociatedEmails(timeline);
    }

    public async Task GetAssociatedEmails(ApplicationTimeline timeline)
    {
        fetchingEmails = true;
        //List<Message>? fetchedEmails = new();
        List<string> allAssociatedEmailStrings = new();
        List<Message>? fetchedEmails = new();

        foreach (var email in timeline.associatedEmailAddresses)
        {
            allAssociatedEmailStrings.Add(email);
        }

        var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
        var filter = string.Join(" or ", emailFilters);

        var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
        {
            requestConfiguration.QueryParameters.Filter = filter;
        });

        fetchedEmails = result?.Value;
        //selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.ReceivedDateTime).ToList();
        if (fetchedEmails != null)
        {
            selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.ReceivedDateTime).ToList();
        }

        fetchingEmails = false;
        StateHasChanged();
    }

    public async void RemoveEmail(string email, int timelineID)
    {
        var response = await backendApiService.removeEmail(email, Username, timelineID);


        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            List<string?> allAssociatedEmailStrings = new();
            foreach (var emailString in newTimeline.associatedEmailAddresses)
            {
                allAssociatedEmailStrings.Add(emailString);
            }

            if (allAssociatedEmailStrings.Count() == 0)
            {
                if (index != -1)
                {
                    newTimeline.hasUnreadEmails = false;
                    timelines[index] = newTimeline;

                    StateHasChanged();
                }

            }
            else
            {
                var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
                var filter = string.Join(" or ", emailFilters);

                var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
                {
                    requestConfiguration.QueryParameters.Filter = filter;
                });

                var fetchedEmails = result?.Value;
                Console.WriteLine(fetchedEmails.Count());

                if (index != -1)
                {
                    newTimeline.hasUnreadEmails = fetchedEmails.Exists(msg => msg.IsRead.HasValue ? !msg.IsRead.Value : false);
                    timelines[index] = newTimeline;

                    StateHasChanged();
                }
            }
        }
    }

    public async void RemoveAssessment(Assessment assessment, int timelineID)
    {
        var response = await backendApiService.removeAssessment(assessment, Username, timelineID);

        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            if (index != -1)
            {
                newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails;
                timelines[index] = newTimeline;
                StateHasChanged();
            }
        }

    }

    public async void CreateApplicant()
    {
        creatingApplicant = true;
        var response = await backendApiService.createApplicant(Username);

        if (response)
        {
            timelines = new List<ApplicationTimeline>();
            isRegistered = true;
            creatingApplicant = false;
            StateHasChanged();
        }

    }


    [CascadingParameter] IModalService ModalInputPopup { get; set; } = default!;

    private async Task ShowModal(int timelineID)
    {
        var inputPopupModal = ModalInputPopup.Show<InputPopup>();
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            string newEmail = result.Data?.ToString();
            if (newEmail != "")
            {
                var response = await backendApiService.addEmail(newEmail, Username, timelineID);
                var filter = $"from/emailAddress/address eq '{newEmail}'";

                var emailsResponse = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
                {
                    requestConfiguration.QueryParameters.Filter = filter;
                });

                var fetchedEmails = emailsResponse?.Value;
                bool newHasUnread = fetchedEmails.Exists(msg => msg.IsRead.HasValue ? !msg.IsRead.Value : false);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {

                        newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails ? true : newHasUnread;
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowAddTimelineModal()
    {
        var inputPopupModal = ModalInputPopup.Show<AddTimelinePopup>();
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            TimelineBson? newTimelineBson = result.Data as TimelineBson;
            if (newTimelineBson != null)
            {
                int newTimelineID = await backendApiService.addTimeline(Username, newTimelineBson);
                if (newTimelineID != -1)
                {
                    try
                    {
                        ApplicationTimeline newTimeline = await backendApiService.getUserTimelineAsync(Username, newTimelineID);
                        timelines.Add(newTimeline);
                        StateHasChanged();
                    }
                    catch
                    {
                        ;
                    }
                }

            }

        }
    }

    private async Task ShowAssessmentModal(int timelineID)
    {
        var assessmentModal = ModalInputPopup.Show<AssessmentInputPopup>();
        var result = await assessmentModal.Result;

        if (result.Confirmed)
        {
            Assessment? newAssessment = result.Data as Assessment;
            if (newAssessment != null)
            {
                var response = await backendApiService.addAssessment(newAssessment, Username, timelineID);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {
                        newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails;
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowRemoveTimelineModal(int timelineID)
    {
        var removeTimelinePopup = ModalInputPopup.Show<RemoveTimelinePopup>();
        var result = await removeTimelinePopup.Result;

        if (result.Confirmed)
        {
            var response = await backendApiService.removeTimeline(Username, timelineID);
            if (response)
            {
                timelines = await backendApiService.getUserTimelinesAsync(Username);
                StateHasChanged();
            }
        }
    }

    private DateTime GetUtcStartOfWeekInTimeZone(DateTime today, string timeZoneId)
    {
        // Time zone returned by Graph could be Windows or IANA style
        // TimeZoneConverter can take either
        TimeZoneInfo userTimeZone = TZConvert.GetTimeZoneInfo(timeZoneId);

        // Assumes Sunday as first day of week
        int diff = System.DayOfWeek.Sunday - today.DayOfWeek;

        // create date as unspecified kind
        var unspecifiedStart = DateTime.SpecifyKind(today.AddDays(diff), DateTimeKind.Unspecified);

        // convert to UTC
        return TimeZoneInfo.ConvertTimeToUtc(unspecifiedStart, userTimeZone);
    }

    private string FormatIso8601DateTime(string? iso8601DateTime)
    {
        if (string.IsNullOrEmpty(iso8601DateTime))
        {
            return string.Empty;
        }

        // Load into a DateTime
        var dateTime = DateTime.Parse(iso8601DateTime);

        if (!string.IsNullOrWhiteSpace(dateTimeFormat))
        {
            // Format it using the user's settings
            return dateTime.ToString(dateTimeFormat);
        }

        // Fallback to return original value
        return iso8601DateTime;
    }


    }

