@page "/applicationtracker"
@using System.Security.Authentication
@using Microsoft.Graph
@using Microsoft.Graph.Models
@using TimeZoneConverter
@using SharedModels.Models
@using GraphSample.ReusableComponents


@inject GraphSample.Services.IBackendApiService backendApiService
@inject GraphSample.Graph.GraphClientFactory clientFactory

<AuthorizeView>
    <Authorized>
        <h1 class="mb-3">Application Dashboard</h1>
        @if (fetchingTimelines || creatingApplicant)
        {
            <FluentProgressRing></FluentProgressRing>
        }
        else if (!isRegistered)
        {
            <button class="btn btn-primary" @onclick="() => CreateApplicant()">Start Your Application Journey Now!</button>
        }
        else
        {
    <div class="container">
        <div class="left-div">
            <table class="table">
                <thead>
                    <tr>
                        <th></th>
                        <th>Comapny</th>
                        <th>Role</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var timeline in timelines)
                    {
                        <tr height="2.5em">
                            @if (emailsShowing && emailsShowingTimeline == timeline.timelineID)
                            {
                                <td width="30%">
                                    <div calss="flex-container">
                                    <span class="remove-button" @onclick="() => ShowRemoveTimelineModal(timeline.timelineID)"><FluentIcon Name="@FluentIcons.Delete" Color="@Color.Error"></FluentIcon></span>
                                    <button class="fixed-height-row-button" @onclick="() => emailsShowing = false">Hide emails</button>
                                    </div>
                                </td>
                            }
                            else
                            {
                                <td width="30%">
                                    <div calss="flex-container">
                                    <span class="remove-button" @onclick="() => ShowRemoveTimelineModal(timeline.timelineID)"><FluentIcon Name="@FluentIcons.Delete" Color="@Color.Error"></FluentIcon></span>
                                    <button class="fixed-height-row-button" @onclick="() => ShowEmails(timeline)">Show emails</button>
                                    </div>
                                </td>
            }
                                <td width="30%">
                                        <div class="company-content">
                                            <p>@timeline.company</p>
                                            @if (timeline.hasUnreadEmails)
                                            {
                                                <p>Unread emails</p>
                                            }
                                        </div>
                                    </td>
                                    <td width="40%"><div class="role-content">@timeline.role</div></td>
                                </tr>
                            }
                            <button class="btn btn-primary" @onclick="() => ShowAddTimelineModal()">Add Timeline</button>
                        </tbody>
                    </table>
                </div>
        <div class="right-div">
            @if (!emailsShowing)
            {
                <div class="container">
                    <div class="right-left-div">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>
                                        Associated emails
                                    </th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var timeline in timelines)
                                {
                                    <tr height="2.5em">
                                        <td width="20%"> <span class="add-button" @onclick="() => ShowAddEmailModal(timeline.timelineID)"><FluentIcon Name="@FluentIcons.AddSquare" Color="@Color.Success" Variant="@IconVariant.Filled"></FluentIcon></span></td>
                                        <td width="60%">
                                            <div class="email-container">
                                                @foreach (var email in timeline.associatedEmailAddresses)
                                                {
                                                    <div style="overflow-x: scroll">@email</div>
                                                    <span class="remove-button" @onclick="() => RemoveEmail(email, timeline.timelineID)"><FluentIcon Name="@FluentIcons.DismissSquare" Color="@Color.Error" Variant="@IconVariant.Filled"></FluentIcon></span>
                                                }
                                            </div>
                                        </td>
                                        <td width="20%"> <span class="add-button" @onclick="() => ShowAddAssessmentModal(timeline.timelineID)"><FluentIcon Name="@FluentIcons.AddSquare" Color="@Color.Success" Variant="@IconVariant.Filled"></FluentIcon></span></td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                    <div class="right-right-div">
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Assessments</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var timeline in timelines)
                                {
                                    <tr height="2.5em">
                                        <td width="100%">
                                            <div class="assessments-container">
                                                @foreach (var assessment in timeline.assessments)
                                                {
                                                    <div class="pane @("status" + assessment.status)">
                                                        <div style="display: flex">
                                                            <div>
                                                                @((assessment.type != AssessmentType.Custom) ? assessment.type.ToString().Replace("_", " ") : assessment.customDescription)
                                                            </div>
                                                            <span class="remove-button" @onclick="() => RemoveAssessment(assessment, timeline.timelineID)"><FluentIcon Name="@FluentIcons.DismissSquare" Color="@Color.Error" Variant="@IconVariant.Filled"></FluentIcon></span>
                                                        </div>
                                                        <div>
                                                            <select class="status-select" @onchange="(e) => HandleStatusChange(timeline, assessment,  Enum.Parse<AssessmentStatus>(e.Value.ToString()))">
                                                                <option value="@assessment.status">@assessment.status</option>
                                                                @foreach (AssessmentStatus option in Enum.GetValues(typeof(AssessmentStatus)))
                                                                {
                                                                    <option value="@option">@option</option>
                                                                }
                                                            </select>
                                                        </div>
                                                        <div>@assessment.date</div>
                                                    </div>
                                                }
                                            </div>
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            }
            else
            {
                @if (fetchingEmails)
                {
                    <div class="container">
                        <FluentProgressRing></FluentProgressRing>
                    </div>
                        }
                        else
                        {
                        <table class="my-table">
                            <thead>
                                <tr>
                                    <th>Sender</th>
                                    <th>Sent Time</th>
                                    <th>Subject</th>
                                    <th>Body</th>
                                    <th>Unread</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var email in selectedAssociatedEmails)
                                {
                                    <tr>
                                        <td>@email.Sender.EmailAddress.Address</td>
                                        <td>@email.ReceivedDateTime</td>
                                        <td>@email.Subject</td>
                                        <td>@(new MarkupString(email.Body.Content))</td>
                                        <td>@email.IsRead</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                        }
                        }
                    </div>
                </div>
        }
    </Authorized>
    <NotAuthorized>
        <RedirectToLogin />
    </NotAuthorized>
</AuthorizeView>

<style>


    .assessments-container {
        border: 1px solid transparent;
        border-right: none;
        height: 75px;
        width: 100%;
        overflow-x: visible;
        position: relative;
        white-space: nowrap;
        padding-bottom: 14px;
    }

    .pane {
        width: 33%;
        height: 70px;
        border: 2px solid #ccc;
        border-radius: 10px;
        display: -moz-inline-box;
        display: inline-block;
        overflow: auto;
    }

    .pane.statusPending {
        background-color: rgba(255, 255, 0, 0.5); /* Yellow semi-translucent color */
        }


    .pane.statusPassed {
        background-color: rgba(0, 255, 0, 0.5); /* Green semi-translucent color */
        }


    .pane.statusScheduled {
        background-color: rgba(0, 0, 255, 0.5); /* Blue semi-translucent color */
        }


    .pane.statuesFailed {
        background-color: rgba(128, 128, 128, 0.5); /* Gray semi-translucent color */
        }

    .email-container {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        height: 75px;
        width: 100%;
        overflow-y: scroll;
        overflow-x: scroll;
    }

    .add-button {
        margin-right: 0.5em;
        cursor: pointer;
        color: green;
    }

    .remove-button {
        cursor: pointer;
        color: red;
        margin-left: 0.5em;
    }

    .red-button {
        background-color: red;
        color: white;
    }
    .container {
        display: flex;
        width: 100%;
    }

    .main-div {
        flex: 1; 
    }

    .left-div {
        width: 30%;
    }

    .right-div {
        width: 70%;
    }

    .right-left-div {
        width: 30%;
    }

    .right-right-div {
        width: 70%;
        overflow-x: scroll;
    }

    .company-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        overflow-y: scroll;
        width: 100%;
        text-align: center;
    }
    .role-content {
        display: flex;
        flex-wrap: wrap;
        height: 75px;
        width: 100%;
        overflow-y: scroll;
        text-align: center;
    }


    .fixed-height-row-button {
        padding: 4px 8px; 
        font-size: 10px;
    }

    .my-table {
        border-collapse: collapse;
    }

    .my-table th, .my-table td {
         border: 1px solid black;
         padding: 8px;
        }

    .status-select {
        background-color: transparent;
    }

    .flex-container {
        display: flex;
        justify-content: center;
    }


</style>

@code {

    [CascadingParameter]
    private Task<AuthenticationState>? authenticationStateTask { get; set; }

    private GraphServiceClient? graphClient;
    private string? dateTimeFormat;
    private string userTimeZone = string.Empty;
    private List<ApplicationTimeline>? timelines;
    private bool emailsShowing;
    private int emailsShowingTimeline;
    //private List<Message>? selectedAssociatedEmails;
    private List<Message> selectedAssociatedEmails;

    private bool fetchingEmails = false;
    private bool fetchingTimelines = false;
    private bool creatingApplicant = false;

    private string Username;
    private bool isRegistered;

    private IList<Message> allMessages = new List<Message>();
    public HashSet<string> allSenders;

    protected override async Task OnInitializedAsync()

    {
        if (authenticationStateTask == null)
        {
            throw new AuthenticationException(
                "Unable to access authentication state");
        }

        // Get the user's time zone
        var user = (await authenticationStateTask).User;
        Username = user.Identity?.Name;
        var graphTimeZone = user.GetUserGraphTimeZone();
        dateTimeFormat = $"{user.GetUserGraphDateFormat()} {user.GetUserGraphTimeFormat()}";
        // Calculate the start and end of the current week in user's time zone
        var startOfWeek = GetUtcStartOfWeekInTimeZone(DateTime.Today, graphTimeZone);
        var endOfWeek = startOfWeek.AddDays(7);

        graphClient = clientFactory.GetAuthenticatedClient();
        emailsShowing = false;
        fetchingTimelines = true;
        timelines = await backendApiService.getUserTimelinesAsync(Username);

        if (timelines != null)
        {

            //experimental
            isRegistered = true;
            List<Message> allAssociatedEmails = new();
            List<string> allAssociatedEmailStrings = new();
            //Dictionary<string, int> emailCounts = new Dictionary<string, int>();
            foreach (var currentAssociatedEmails in timelines.Select(t => t.associatedEmailAddresses))
            {
                foreach (var email in currentAssociatedEmails)
                {
                    allAssociatedEmailStrings.Add(email);
                }
            }

            var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
            var filter = string.Join(" or ", emailFilters);

            var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
            {
                requestConfiguration.QueryParameters.Filter = filter;
            });

            //if (result != null)
            //{

            //    foreach (var email in allAssociatedEmailStrings)
            //    {
            //        int count = result.Value.Count(msg => msg.Sender.EmailAddress.Address == email);
            //        emailCounts[email] = count;
            //    }
            //}
            //foreach (var timeline in timelines)
            //{
            //    int totalCount = 0;
            //    foreach (var email in timeline.associatedEmailAddresses) { totalCount += emailCounts[email]; }
            //    if (totalCount != timeline.readEmailCount) { timeline.hasUnreadEmails = true; }
            //}

            var groupedEmails = result.Value.GroupBy(msg => msg.Sender.EmailAddress.Address).
                ToDictionary(group => group.Key, group => group.ToList());

            for (int i = 0; i < timelines.Count(); i++)
            {
                var timeline = timelines[i];
                bool loopFlag = false;
                foreach (var email in timeline.associatedEmailAddresses)
                {
                    if (loopFlag) { break; }
                    if (groupedEmails.ContainsKey(email))
                    {
                        var messages = groupedEmails[email];
                        foreach (var msg in messages)
                        {
                            if (msg.IsRead == false)
                            {
                                timelines[i].hasUnreadEmails = true;
                                loopFlag = true;
                                break;
                            }
                        }
                    }
                }
            }


            var mailPage = await graphClient.Me
            .MailFolders["Inbox"]
            .Messages
            .GetAsync(config =>
            {
                config.Headers.Add("Prefer", $"outlook.timezone=\"{graphTimeZone}\"");
                config.QueryParameters.Select = new string[] { "sender" };
                config.QueryParameters.Orderby = new string[] { "receivedDateTime desc" };
            });

            allMessages = mailPage?.Value ?? new List<Message>();
            allSenders = new HashSet<string>(allMessages.Select(msg => msg.Sender.EmailAddress.Address));

            fetchingTimelines = false;
        }
        else
        {
            isRegistered = false;
        }

        fetchingTimelines = false;

    }
    public async void ShowEmails(ApplicationTimeline timeline)
    {
        emailsShowing = true;
        emailsShowingTimeline = timeline.timelineID;
        await GetAssociatedEmails(timeline);
    }

    public async Task GetAssociatedEmails(ApplicationTimeline timeline)
    {
        fetchingEmails = true;
        //List<Message>? fetchedEmails = new();
        List<string> allAssociatedEmailStrings = new();
        List<Message>? fetchedEmails = new();

        if (timeline.associatedEmailAddresses.Count() == 0)
        {
            selectedAssociatedEmails = new List<Message>();
            fetchingEmails = false;
            StateHasChanged();
            return;
        }

        foreach (var email in timeline.associatedEmailAddresses)
        {
            allAssociatedEmailStrings.Add(email);
        }

        var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
        var filter = string.Join(" or ", emailFilters);

        var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
        {
            requestConfiguration.QueryParameters.Filter = filter;
        });

        fetchedEmails = result?.Value;
        //selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.ReceivedDateTime).ToList();
        if (fetchedEmails != null)
        {
            selectedAssociatedEmails = fetchedEmails.OrderByDescending(m => m.ReceivedDateTime).ToList();
        }

        fetchingEmails = false;
        StateHasChanged();
    }

    public async void RemoveEmail(string email, int timelineID)
    {
        var response = await backendApiService.removeEmail(email, Username, timelineID);


        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            List<string?> allAssociatedEmailStrings = new();
            foreach (var emailString in newTimeline.associatedEmailAddresses)
            {
                allAssociatedEmailStrings.Add(emailString);
            }

            if (allAssociatedEmailStrings.Count() == 0)
            {
                if (index != -1)
                {
                    newTimeline.hasUnreadEmails = false;
                    timelines[index] = newTimeline;

                    StateHasChanged();
                }

            }
            else
            {
                var emailFilters = allAssociatedEmailStrings.Select(email => $"from/emailAddress/address eq '{email}'");
                var filter = string.Join(" or ", emailFilters);

                var result = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
                {
                    requestConfiguration.QueryParameters.Filter = filter;
                });

                var fetchedEmails = result?.Value;
                Console.WriteLine(fetchedEmails.Count());

                if (index != -1)
                {
                    newTimeline.hasUnreadEmails = fetchedEmails.Exists(msg => msg.IsRead.HasValue ? !msg.IsRead.Value : false);
                    timelines[index] = newTimeline;

                    StateHasChanged();
                }
            }
        }
    }


    public async void RemoveAssessment(Assessment assessment, int timelineID)
    {
        var response = await backendApiService.removeAssessment(assessment, Username, timelineID);

        if (response)
        {
            var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
            int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
            if (index != -1)
            {
                newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails;
                timelines[index] = newTimeline;
                StateHasChanged();
            }
        }

    }


    public async void CreateApplicant()
    {
        creatingApplicant = true;
        var response = await backendApiService.createApplicant(Username);

        if (response)
        {
            timelines = new List<ApplicationTimeline>();
            isRegistered = true;
            creatingApplicant = false;
            StateHasChanged();
        }

    }

    private async Task HandleStatusChange(ApplicationTimeline timeline, Assessment assessment, AssessmentStatus newStatus)
    {
        var response = await backendApiService.updateAssessmentStatus(assessment, Username, timeline.timelineID, newStatus);
        if (response)
        {
            int index = timelines.FindIndex(tl => tl.timelineID == timeline.timelineID);
            if (index != -1)
            {
                var assessments = timelines[index].assessments;
                int assessmentsIndex = assessments.FindIndex(a => a.date == assessment.date);
                assessments[assessmentsIndex].status = newStatus;
                StateHasChanged();
            }
        }

    }


    [CascadingParameter] IModalService ModalInputPopup { get; set; } = default!;

    private async Task ShowAddEmailModal(int timelineID)
    {
        var parameters = new ModalParameters()
            .Add(nameof(ApplicationTracker.allSenders), allSenders);

        var inputPopupModal = ModalInputPopup.Show<InputPopup>("Passing Data", parameters);
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            string newEmail = result.Data?.ToString();
            if (newEmail != "")
            {
                var response = await backendApiService.addEmail(newEmail, Username, timelineID);
                var filter = $"from/emailAddress/address eq '{newEmail}'";

                var emailsResponse = await graphClient.Me.Messages.GetAsync((requestConfiguration) =>
                {
                    requestConfiguration.QueryParameters.Filter = filter;
                });

                var fetchedEmails = emailsResponse?.Value;
                bool newHasUnread = fetchedEmails.Exists(msg => msg.IsRead.HasValue ? !msg.IsRead.Value : false);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {

                        newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails ? true : newHasUnread;
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowAddTimelineModal()
    {
        var inputPopupModal = ModalInputPopup.Show<AddTimelinePopup>();
        var result = await inputPopupModal.Result;

        if (result.Confirmed)
        {
            TimelineBson? newTimelineBson = result.Data as TimelineBson;
            if (newTimelineBson != null)
            {
                int newTimelineID = await backendApiService.addTimeline(Username, newTimelineBson);
                if (newTimelineID != -1)
                {
                    try
                    {
                        ApplicationTimeline newTimeline = await backendApiService.getUserTimelineAsync(Username, newTimelineID);
                        timelines.Add(newTimeline);
                        StateHasChanged();
                    }
                    catch
                    {
                        ;
                    }
                }

            }

        }
    }

    private async Task ShowAddAssessmentModal(int timelineID)
    {
        var assessmentModal = ModalInputPopup.Show<AssessmentInputPopup>();
        var result = await assessmentModal.Result;

        if (result.Confirmed)
        {
            Assessment? newAssessment = result.Data as Assessment;
            if (newAssessment != null)
            {
                var response = await backendApiService.addAssessment(newAssessment, Username, timelineID);
                if (response)
                {
                    var newTimeline = await backendApiService.getUserTimelineAsync(Username, timelineID);
                    int index = timelines.FindIndex(tl => tl.timelineID == timelineID);
                    if (index != -1)
                    {
                        newTimeline.hasUnreadEmails = timelines[index].hasUnreadEmails;
                        timelines[index] = newTimeline;
                        StateHasChanged();
                    }
                }

            }
        }
    }

    private async Task ShowRemoveTimelineModal(int timelineID)
    {
        var removeTimelinePopup = ModalInputPopup.Show<RemoveTimelinePopup>();
        var result = await removeTimelinePopup.Result;

        if (result.Confirmed)
        {
            var response = await backendApiService.removeTimeline(Username, timelineID);
            if (response)
            {
                timelines = await backendApiService.getUserTimelinesAsync(Username);
                StateHasChanged();
            }
        }
    }

    private DateTime GetUtcStartOfWeekInTimeZone(DateTime today, string timeZoneId)
    {
        // Time zone returned by Graph could be Windows or IANA style
        // TimeZoneConverter can take either
        TimeZoneInfo userTimeZone = TZConvert.GetTimeZoneInfo(timeZoneId);

        // Assumes Sunday as first day of week
        int diff = System.DayOfWeek.Sunday - today.DayOfWeek;

        // create date as unspecified kind
        var unspecifiedStart = DateTime.SpecifyKind(today.AddDays(diff), DateTimeKind.Unspecified);

        // convert to UTC
        return TimeZoneInfo.ConvertTimeToUtc(unspecifiedStart, userTimeZone);
    }

    private string FormatIso8601DateTime(string? iso8601DateTime)
    {
        if (string.IsNullOrEmpty(iso8601DateTime))
        {
            return string.Empty;
        }

        // Load into a DateTime
        var dateTime = DateTime.Parse(iso8601DateTime);

        if (!string.IsNullOrWhiteSpace(dateTimeFormat))
        {
            // Format it using the user's settings
            return dateTime.ToString(dateTimeFormat);
        }

        // Fallback to return original value
        return iso8601DateTime;
    }


    }
