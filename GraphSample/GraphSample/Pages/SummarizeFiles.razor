@page "/SummariseFiles"

@using System.Security.Authentication
@using System.IO;
@using GrapeCity.Documents.Pdf;
@using DocumentFormat.OpenXml.Packaging;
@using Azure
@using Azure.AI.OpenAI
@using System.Text
@using Microsoft.Graph
@using Microsoft.Graph.Models
@using Microsoft.Graph.Models.ODataErrors;
@using Microsoft.Kiota.Abstractions
@using Microsoft.Kiota.Abstractions.Serialization
@inject GraphSample.Graph.GraphClientFactory clientFactory
@inject GraphSample.AI.OpenAIService OpenAIService


@inject GraphSample.Graph.GraphClientFactory clientFactory
@inject ILogger<FileUpload> Logger
@inject GraphSample.AI.OpenAIService OpenAIService

<style>

    .dropdown-content {
        max-height: 100%;
        overflow: scroll;
        max-width: 99%;
    }

    .textbox {
        margin: 10vw;
        min-height: 50vh;
        min-width: 50vw;
        max-height: 50vh;
        max-width: 50vw;
        background-color: ghostwhite;
        color: black;
        overflow: scroll;
        border-radius: 0.25rem;
    }

</style>


<AuthorizeView>

    <Authorized>

        <div class="dropdown">
            <button class="btn btn-primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                SmartScribe
            </button>
            <ul class="dropdown-menu">
                <li class="dropdown-item">Upload PDF File <InputFile OnChange="@LoadFile" /></li>
                <li class="dropdown-item" @onclick="OnOpen"> Upload from OneDrive </li>

            </ul>
        </div>

        <div>
            <FluentDialog @ref="MyFluentDialog" aria-label="Simple dialog" Modal=true @ondialogdismiss=OnDismiss>
                <div class="dropdown-content">

                    @foreach (var file in data_response)
                    {
                        string npath = path + file.Id;
                        <mgt-file file-query="@npath" @onclick="() => GetContent(file.Id)"></mgt-file>
                    }

                </div>

            </FluentDialog>
        </div>

        <button class="btn btn-success" @onclick="SummarizeFile"> Summarize </button>
        <button class="btn btn-warning" @onclick="WriteToOneNote"> Write To OneNote </button>

        @if (isLoading)
        {
            <p>Uploading...</p>
        }

        
            
        @if (isSummarizing)
        {
            <div class="textbox">
                <p>Summarizing...</p>
                <FluentProgressRing></FluentProgressRing>
            </div>
        }
        
        else if (isWriting)
        {
            <div class="textbox">
                <p>Writing to OneNote...</p>
                <FluentProgressRing></FluentProgressRing>
                <h3>Summary:</h3>
                <p>@summary</p>
            </div>
        }
        
        else if (!string.IsNullOrEmpty(summary))
        {
            <div class="textbox">
                <h3>Summary:</h3>
                <p>@summary</p>
            </div>
        }

        @if (noSummary)
        {
            <div class="textbox">
                <p>No summary to write to OneNote yet...</p>
            </div>
        }


        

    </Authorized>

    <NotAuthorized>
        <RedirectToLogin />
    </NotAuthorized>

</AuthorizeView>

@code{

    //ToDo:
    //    1.  Return tuple instead for PDF/DOC/ppt to refactor
    //    2. Apply error handling to GetContent so folders not clicked
    //    3. Clean up the AI function too bulky
    //    4. OneNote button (Angus)

    [CascadingParameter]
    protected Task<AuthenticationState>? authenticationStateTask { get; set; }
    private FluentDialog? MyFluentDialog;
    public bool Modal = true;
    private GraphServiceClient? graphClient;
    private List<DriveItem> data_response = new List<DriveItem>();
    protected const string path = "/me/drive/items/";
    protected string driveId = "";
    protected string itemId = "";
    protected string summary = "";
    protected bool uploadMethod = true; // true for file upload, false for M365

    //File Upload variables
    private List<IBrowserFile> loadedFile = new();
    private long maxFileSize = 1024 * 100000;
    private int maxAllowedFiles = 1;
    private bool isLoading;
    private bool isSummarizing;
    private bool isWriting;
    private bool noSummary;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
            MyFluentDialog!.Hide();
    }

    protected override async Task OnInitializedAsync()
    {
        await listFiles();
    }

    private async void OnOpen()
    {
        MyFluentDialog!.Show();
        uploadMethod = false;
        await listFiles();

    }

    private void OnDismiss(DialogEventArgs args)
    {
        if (args is not null && args.Reason is not null && args.Reason == "dismiss")
        {
            MyFluentDialog!.Hide();
        }
    }

    // Loading files
    private void LoadFile(InputFileChangeEventArgs e)
    {
        isLoading = true;
        loadedFile.Clear();

        foreach (var file in e.GetMultipleFiles(maxAllowedFiles))
        {
            loadedFile.Add(file);
        }
        isLoading = false;
    }


    // apply error handling to not click on folders
    // Can do regex to check if path is folder
    protected void GetContent(string path)
    {

        Console.WriteLine("Clicked on: " + path);
        itemId = path;
        MyFluentDialog!.Hide();

    }

    // Extracts all the text from file
    private async Task<string> ExtractAllTextAsync(IBrowserFile file)
    {
        using var memoryStream = new MemoryStream();
        await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
        var document = new GcPdfDocument();
        document.Load(memoryStream);
        var text = document.GetText();
        return text;
    }

    public async Task<Stream> ConvertToStream(IBrowserFile file)
    {
        var memoryStream = new MemoryStream();
        await file.OpenReadStream(maxFileSize).CopyToAsync(memoryStream);
        memoryStream.Seek(0, SeekOrigin.Begin);
        return memoryStream;
    }


    private async Task SummarizeFile()
    {
        summary = "";
        var content = "";
        isSummarizing = true; // Set the flag to indicate that summarization is in progress

        if (uploadMethod)
        {
            if (loadedFile.Count == 0) return;

            // Read the content of the file
            var file = loadedFile[0];
            Stream stream = await ConvertToStream(file);
            content = ExtractTextFromStream(stream);

            Console.WriteLine("Extracted text");
        }

        else
        {
            if (authenticationStateTask == null)
            {
                throw new AuthenticationException(
                    "Unable to access authentication state");
            }

            var user = (await authenticationStateTask).User;
            var contentStream = await graphClient.Drives[driveId].Items[itemId].Content.GetAsync();
            content = ExtractTextFromStream(contentStream);

            Console.WriteLine("Got text response");
        }


        await SummarizeText(content);

        isSummarizing = false;
        Console.WriteLine(summary);
    }


    // Event handler for the "Summarize" button click
    protected async Task SummarizeText(string content)
    {

        // Perform summarization until the overall summary is less than 3000 characters
        var summaries = new List<string>();
        var overallSummary = "";
        Console.WriteLine("Inside ai: " + content);

        // Split the content into smaller chunks
        var chunkSize = 750; // Adjust this value as per your model's character limit
        var chunks = SplitContentIntoChunks(content, chunkSize);

        // Perform summarization for each chunk
        foreach (var chunk in chunks)
        {
            string prompt = $"Summarize the following text in a professional and business like manner and in extreme detail (Include any equations mentioned):\n\n{chunk}\n";
            //Console.Write($"Input: {prompt}\n");

            var completionsResponse = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, prompt);
            var completion = completionsResponse.Value.Choices[0].Text;
            //Console.Write($"Completion: {completion}\n");
            summaries.Add(completion);
            string finish = $"Keep summarising in extreme detail:\n\n{prompt}\n\nGave summary:\n\n{completion}";
            var completionsResponseFinish = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish);
            var completionFinish = completionsResponseFinish.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish);
            string finish2 = $"Keep summarising in extreme detail:\n\n{prompt}\n\nGave summary:\n\n{completionFinish}";
            var completionsResponseFinish2 = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish2);
            var completionFinish2 = completionsResponseFinish2.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish2);
        }

        // Combine the individual summaries into an overall summary
        overallSummary = string.Join(" ", summaries);

        //Break the loop if the overall summary exceeds 2500 characters
        if (overallSummary.Length >= 2500)
        {
            summaries.Clear();

            string prompt = $"This summary is slightly too long, please rewrite without losing any detail but in a more concise way:\n\n{overallSummary}\n";
            //Console.Write($"Input: {prompt}\n");
            var completionsResponse = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, prompt);
            var completion = completionsResponse.Value.Choices[0].Text;
            //Console.Write($"Completion: {completion}");
            summaries.Add(completion);
            string finish = $"Keep summarising in extreme detail:\n\n{prompt}\n\nGave summary:\n\n{completion}";
            var completionsResponseFinish = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish);
            var completionFinish = completionsResponseFinish.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish);
            string finish2 = $"Keep summarising in extreme detail:\n\n{prompt}\n\nGave summary:\n\n{completionFinish}";
            var completionsResponseFinish2 = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish2);
            var completionFinish2 = completionsResponseFinish2.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish2);
        }

        //Break the loop if the overall summary exceeds 2500 characters
        else if (overallSummary.Length <= 500)
        {
            summaries.Clear();

            string prompt = $"This summary is slightly too short, please rewrite without losing any detail but in a more easy to understand way, including any extra details that would help:\n\n{overallSummary}\n";
            //Console.Write($"Input: {prompt}\n");
            var completionsResponse = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, prompt);
            var completion = completionsResponse.Value.Choices[0].Text;
            //Console.Write($"Completion: {completion}");
            summaries.Add(completion);
            string finish = $"Keep summarising:\n\n{prompt}\n\nGave summary:\n\n{completion}";
            var completionsResponseFinish = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish);
            var completionFinish = completionsResponseFinish.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish);
            string finish2 = $"Keep summarising in extreme detail:\n\n{prompt}\n\nGave summary:\n\n{completionFinish}";
            var completionsResponseFinish2 = await OpenAIService.client.GetCompletionsAsync(OpenAIService.engine, finish2);
            var completionFinish2 = completionsResponseFinish2.Value.Choices[0].Text;
            //Console.Write($"Completion: {completionFinish}\n");
            summaries.Add(completionFinish2);
        }

        overallSummary = string.Join(" ", summaries);
        summaries.Clear();
        summary = overallSummary;
        Console.WriteLine("Generated AI summary");

    }

    // Helper method to split the content into smaller chunks
    private IEnumerable<string> SplitContentIntoChunks(string content, int chunkSize)
    {
        var sentences = content.Split('.', '!', '?');
        var currentChunk = new StringBuilder();

        foreach (var sentence in sentences)
        {
            if (currentChunk.Length + sentence.Length + 1 <= chunkSize)
            {
                currentChunk.Append(sentence).Append('.');
            }
            else
            {
                yield return currentChunk.ToString();
                currentChunk.Clear().Append(sentence).Append('.');
            }
        }

        if (currentChunk.Length > 0)
        {
            yield return currentChunk.ToString();
        }
    }

    // Maybe return tuple instead
    protected string ExtractTextFromStream(Stream input)
    {
        string text = "";

        if (IsPDF(input))
        {
            text = ExtractTextFromPDF(input);
            Console.WriteLine("Is PDF");
        }
        else if (IsWordDocument(input))
        {
            text = ExtractTextFromWord(input);
            Console.WriteLine("Is Word");
        }
        else if (IsPowerPointDocument(input))
        {
            text = ExtractTextFromPowerPoint(input);
            Console.WriteLine("Is PPT");
        }

        return text;
    }

    private bool IsPDF(Stream stream)
    {
        try
        {
            var document = new GcPdfDocument();
            document.Load(stream);
            return true;
        }
        catch
        {
            return false;
        }
    }

    public string ExtractTextFromPDF(Stream stream)
    {

        var document = new GcPdfDocument();
        document.Load(stream);
        var text = document.GetText();

        return text;
    }

    private bool IsWordDocument(Stream stream)
    {
        try
        {
            using (var document = WordprocessingDocument.Open(stream, false))
            {
                return true;
            }
        }
        catch
        {
            return false;
        }
    }

    private string ExtractTextFromWord(Stream stream)
    {
        var text = "";

        using (var document = WordprocessingDocument.Open(stream, false))
        {
            var body = document.MainDocumentPart.Document.Body;
            text = body.InnerText;
        }

        return text;
    }

    private bool IsPowerPointDocument(Stream stream)
    {
        try
        {
            using (var presentation = PresentationDocument.Open(stream, false))
            {
                return true;
            }
        }
        catch
        {
            return false;
        }
    }

    private string ExtractTextFromPowerPoint(Stream stream)
    {
        var text = "";

        using (var presentation = PresentationDocument.Open(stream, false))
        {
            var slideText = "";

            foreach (var slidePart in presentation.PresentationPart.SlideParts)
            {
                var slide = slidePart.Slide;
                var paragraphs = slide.Descendants<DocumentFormat.OpenXml.Drawing.Paragraph>();

                foreach (var paragraph in paragraphs)
                {
                    slideText += paragraph.InnerText + " ";
                }
            }

            text = slideText.Trim();
        }

        return text;
    }


    protected async Task listFiles()
    {
        if (authenticationStateTask == null)
        {
            throw new AuthenticationException(
                "Unable to access authentication state");
        }

        // Get the user
        var user = (await authenticationStateTask).User;

        graphClient = clientFactory.GetAuthenticatedClient();

        var driveItem = await graphClient.Me.Drive.GetAsync();
        driveId = driveItem.Id;

        // List children in the drive
        var files = await graphClient.Drives[driveId].Items["root"].Children.GetAsync();
        Console.WriteLine("Getting files...");
        data_response = files.Value;

        // The type of files is Microsoft.Graph.Models.DriveItem
    }

    private async Task WriteToOneNote()
    {
        if (summary == "")
        {
            summary = "Hello World";
            //noSummary = true;
            //return;
        }
        var fileName = "";
        if (loadedFile.Count == 0)
        {
            fileName = "summary";
        }
        else
        {
            fileName = loadedFile[0].Name;
        }
        isWriting = true; // Set the flag to indicate that writing to OneNote is in progress
        var user = (await authenticationStateTask).User;
        graphClient = clientFactory.GetAuthenticatedClient();
        var requestBody = new Notebook
        {
            //set the displayName to the name of the uploaded file witha unique ID
            DisplayName = $"{fileName} {DateTime.Now.ToString("yyyyMMddHHmmss")}"
        };
        var result = await graphClient.Me.Onenote.Notebooks.PostAsync(requestBody);

        // Get the ID of the newly created notebook
        var notebookId = result.Id;
        // create a new section in the notebook
        var section = new OnenoteSection
        {
            DisplayName = "Summarized Notes"
        };
        var sectionResult = await graphClient.Me.Onenote.Notebooks[notebookId].Sections.PostAsync(section);
        // Get the ID of the newly created section
        var sectionId = sectionResult.Id;

        // Create the title of the page
        string pageTitle = $"Summary of {fileName}";

        // Create the HTML body content
        string htmlContent =  "<!DOCTYPE html>\n" +
                              "<html>\n" +
                              "    <head>\n" +
                              "         <title>" + pageTitle + "</title>\n" +
                              "         <meta name=\"" + pageTitle + $"\" content=\"{DateTime.Now.ToString("yyyy-MM-dd")}T{DateTime.Now.ToString("HH:mm:ss")}Z\" />\n" +
                              "     </head>\n" +
                              "     <body>\n" +
                              "         <p>" + summary + "</p>\n" +
                              "     </body>\n" +
                              "</html>";

        // Convert the HTML string to a byte array using UTF-8 encoding
        byte[] contentBytes = Encoding.UTF8.GetBytes(htmlContent);
        // create a new page in the section
        //var page = new OnenotePage
        //{
        //     set the title and include a textbox with the content of the summary
        //    Title = pageTitle,
        //    Content = contentBytes
        //};
        //Console.WriteLine(htmlContent);
        //var pageResult = await graphClient.Me.Onenote.Sections[sectionId]
        //    .Pages
        //    .PostAsync(page, requestConfiguration =>
        //    {
        //        requestConfiguration.Headers.Add("Content-Type", "application/xhtml+xml");
        //    });
        //var pageResult = await graphClient.Me.Onenote.Sections[sectionId].Pages.PostAsync(page);
        // Create multipart object with the relevant content
        var multipartContent = new MultipartFormDataContent();
        var htmlString = htmlContent;
        var presentation = new StringContent(htmlString, Encoding.UTF8, "text/html");
        multipartContent.Add(presentation, "Presentation");//needs a name

        // We can add more httpcontent instance here if we wish to

        // create a request information instance and make a request.
        var requestInformation = graphClient.Me.Onenote.Sections[sectionId].Pages.ToGetRequestInformation();
        requestInformation.Headers.Add("Content-Type", multipartContent.Headers.ContentType.ToString());
        requestInformation.HttpMethod = Method.POST;
        requestInformation.Content = await multipartContent.ReadAsStreamAsync();
        var errorMapping = new Dictionary<string, ParsableFactory<IParsable>> {
              {"4XX", ODataError.CreateFromDiscriminatorValue},
              {"5XX", ODataError.CreateFromDiscriminatorValue},
            };
        var pageResult = await graphClient.RequestAdapter.SendAsync<OnenotePage>(requestInformation, OnenotePage.CreateFromDiscriminatorValue, errorMapping);
        isWriting = false; // Set the flag to indicate that writing to OneNote is complete
        Console.WriteLine("Done");
    }
}