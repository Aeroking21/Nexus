import { contrastRatio, isColorStringHexRGB, isColorStringWebRGB, parseColorHexRGB, parseColorWebRGB, rgbToRelativeLuminance, } from '@microsoft/fast-colors';
import { memoize } from 'lodash-es';
/**
 * @internal
 * The states that a swatch can have
 */
export var SwatchFamilyType;
(function (SwatchFamilyType) {
    SwatchFamilyType["rest"] = "rest";
    SwatchFamilyType["hover"] = "hover";
    SwatchFamilyType["active"] = "active";
    SwatchFamilyType["focus"] = "focus";
    SwatchFamilyType["selected"] = "selected";
})(SwatchFamilyType || (SwatchFamilyType = {}));
export function colorRecipeFactory(recipe) {
    const memoizedRecipe = memoize(recipe);
    function curryRecipe(arg) {
        if (typeof arg === 'function') {
            return (designSystem) => {
                return memoizedRecipe(Object.assign({}, designSystem, {
                    backgroundColor: arg(designSystem),
                }));
            };
        }
        else {
            return memoizedRecipe(arg);
        }
    }
    return curryRecipe;
}
/**
 * @internal
 * Helper function to transform a SwatchFamilyResolver into simple ColorRecipe for simple use
 * use in stylesheets.
 */
export function swatchFamilyToSwatchRecipeFactory(type, callback) {
    const memoizedRecipe = memoize(callback);
    return (arg) => {
        if (typeof arg === 'function') {
            return (designSystem) => {
                return memoizedRecipe(Object.assign({}, designSystem, {
                    backgroundColor: arg(designSystem),
                }))[type];
            };
        }
        else {
            return memoizedRecipe(arg)[type];
        }
    };
}
const cache = new Map();
/**
 * Converts a color string into a ColorRGBA64 instance.
 * Supports #RRGGBB and rgb(r, g, b) formats
 *
 * @public
 */
export function parseColorString(color) {
    const cached = cache.get(color);
    if (!cached) {
        let parsed = parseColorHexRGB(color);
        if (parsed === null) {
            parsed = parseColorWebRGB(color);
        }
        if (parsed === null) {
            throw new Error(`${color} cannot be converted to a ColorRGBA64. Color strings must be one of the following formats: "#RGB", "#RRGGBB", or "rgb(r, g, b)"`);
        }
        cache.set(color, parsed);
        return parsed;
    }
    return cached;
}
/**
 * @internal
 * Determines if a string value represents a color
 * Supports #RRGGBB and rgb(r, g, b) formats
 */
export function isValidColor(color) {
    return isColorStringHexRGB(color) || isColorStringWebRGB(color);
}
/**
 * @internal
 * Determines if a color string matches another color.
 * Supports #RRGGBB and rgb(r, g, b) formats
 */
export function colorMatches(a, b) {
    return parseColorString(a).equalValue(parseColorString(b));
}
/**
 * @internal
 * Returns the contrast value between two color strings.
 * Supports #RRGGBB and rgb(r, g, b) formats.
 */
export const contrast = memoize((a, b) => {
    return contrastRatio(parseColorString(a), parseColorString(b));
}, (a, b) => a + b);
/**
 * @internal
 * Returns the relative luminance of a color. If the value is not a color, -1 will be returned
 * Supports #RRGGBB and rgb(r, g, b) formats
 */
export function luminance(color) {
    return rgbToRelativeLuminance(parseColorString(color));
}
/**
 * @internal
 */
export function designSystemResolverMax(...args) {
    return (designSystem) => Math.max.apply(null, args.map((fn) => fn(designSystem)));
}
/**
 * @internal
 */
export const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
