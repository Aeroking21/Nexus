/**
 * Big thanks to https://github.com/fkleuver and the https://github.com/aurelia/aurelia project
 * for the bulk of this code and many of the associated tests.
 */
import { Constructable } from "@microsoft/fast-element";
/**
 * @alpha
 */
export declare type ResolveCallback<T = any> = (handler: Container, requestor: Container, resolver: Resolver<T>) => T;
/**
 * @alpha
 */
export declare type InterfaceSymbol<K = any> = (target: any, property: string, index?: number) => void;
interface ResolverLike<C, K = any> {
    readonly $isResolver: true;
    resolve(handler: C, requestor: C): Resolved<K>;
    getFactory?(container: C): (K extends Constructable ? Factory<K> : never) | null;
}
/**
 * @alpha
 */
export interface Resolver<K = any> extends ResolverLike<Container, K> {
}
/**
 * @alpha
 */
export interface Registration<K = any> {
    register(container: Container, key?: Key): Resolver<K>;
}
/**
 * @alpha
 */
export declare type Transformer<K> = (instance: Resolved<K>) => Resolved<K>;
/**
 * @alpha
 */
export interface Factory<T extends Constructable = any> {
    readonly Type: T;
    registerTransformer(transformer: Transformer<T>): void;
    construct(container: Container, dynamicDependencies?: Key[]): Resolved<T>;
}
/**
 * @alpha
 */
export interface ServiceLocator {
    has<K extends Key>(key: K | Key, searchAncestors: boolean): boolean;
    get<K extends Key>(key: K): Resolved<K>;
    get<K extends Key>(key: Key): Resolved<K>;
    get<K extends Key>(key: K | Key): Resolved<K>;
    getAll<K extends Key>(key: K, searchAncestors?: boolean): readonly Resolved<K>[];
    getAll<K extends Key>(key: Key, searchAncestors?: boolean): readonly Resolved<K>[];
    getAll<K extends Key>(key: K | Key, searchAncestors?: boolean): readonly Resolved<K>[];
}
/**
 * @alpha
 */
export interface Registry {
    register(container: Container, ...params: unknown[]): void | Resolver | Container;
}
/**
 * @alpha
 */
export interface Container extends ServiceLocator {
    register(...params: any[]): Container;
    registerResolver<K extends Key, T = K>(key: K, resolver: Resolver<T>, isDisposable?: boolean): Resolver<T>;
    registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean;
    getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): Resolver<T> | null;
    registerFactory<T extends Constructable>(key: T, factory: Factory<T>): void;
    getFactory<T extends Constructable>(key: T): Factory<T>;
    createChild(config?: Partial<Omit<ContainerConfiguration, "parentLocator">>): Container;
}
/**
 * @alpha
 */
export declare class ResolverBuilder<K> {
    private container;
    private key;
    constructor(container: Container, key: Key);
    instance(value: K): Resolver<K>;
    singleton(value: Constructable): Resolver<K>;
    transient(value: Constructable): Resolver<K>;
    callback(value: ResolveCallback<K>): Resolver<K>;
    cachedCallback(value: ResolveCallback<K>): Resolver<K>;
    aliasTo(destinationKey: Key): Resolver<K>;
    private registerResolver;
}
/**
 * @alpha
 */
export declare type RegisterSelf<T extends Constructable> = {
    register(container: Container): Resolver<InstanceType<T>>;
    registerInRequestor: boolean;
};
/**
 * @alpha
 */
export declare type Key = PropertyKey | object | InterfaceSymbol | Constructable | Resolver;
/**
 * @alpha
 */
export declare type Resolved<K> = K extends InterfaceSymbol<infer T> ? T : K extends Constructable ? InstanceType<K> : K extends ResolverLike<any, infer T1> ? T1 extends Constructable ? InstanceType<T1> : T1 : K;
/**
 * @alpha
 */
export declare type Injectable<T = {}> = Constructable<T> & {
    inject?: Key[];
};
/**
 * @alpha
 */
export declare type ParentLocator = (owner: any) => Container | null;
/**
 * @alpha
 */
export interface ContainerConfiguration {
    parentLocator: ParentLocator;
    responsibleForOwnerRequests: boolean;
    defaultResolver(key: Key, handler: Container): Resolver;
}
/**
 * @alpha
 */
export declare const DefaultResolver: Readonly<{
    none(key: Key): Resolver;
    singleton(key: Key): Resolver;
    transient(key: Key): Resolver;
}>;
/**
 * @alpha
 */
export declare const ContainerConfiguration: Readonly<{
    default: Readonly<ContainerConfiguration>;
}>;
/**
 * @alpha
 */
export interface InterfaceConfiguration {
    /**
     * The friendly name for the interface. Useful for debugging.
     */
    friendlyName?: string;
    /**
     * When true, the dependency will be re-resolved when FASTElement connection changes.
     * If the resolved value changes due to connection change, a {@link @microsoft/fast-element#Observable.notify | notification }
     * will be emitted for the property, with the previous and next values provided to any subscriber.
     */
    respectConnection?: boolean;
}
/**
 * @alpha
 */
export declare const DI: Readonly<{
    createContainer(config?: Partial<ContainerConfiguration> | undefined): Container;
    findResponsibleContainer(element: HTMLElement): Container;
    findParentContainer(element: HTMLElement): Container;
    getOrCreateDOMContainer(element?: HTMLElement, config?: Partial<Pick<ContainerConfiguration, "responsibleForOwnerRequests" | "defaultResolver">> | undefined): Container;
    getDesignParamtypes: (Type: Constructable | Injectable) => readonly Key[] | undefined;
    getAnnotationParamtypes: (Type: Constructable | Injectable) => readonly Key[] | undefined;
    getOrCreateAnnotationParamTypes(Type: Constructable | Injectable): Key[];
    getDependencies(Type: Constructable | Injectable): Key[];
    defineProperty(target: {}, propertyName: string, key: Key, respectConnection?: boolean): void;
    createInterface<K extends Key>(nameConfigOrCallback?: string | InterfaceConfiguration | ((builder: ResolverBuilder<K>) => Resolver<K>) | undefined, configuror?: ((builder: ResolverBuilder<K>) => Resolver<K>) | undefined): InterfaceSymbol<K>;
    inject(...dependencies: Key[]): (target: any, key?: string | number | undefined, descriptor?: number | PropertyDescriptor | undefined) => void;
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example
     * ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient<T extends Constructable<{}>>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example
     * ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     *
     * @alpha
     */
    singleton<T_1 extends Constructable<{}>>(target: T_1 & Partial<RegisterSelf<T_1>>, options?: SingletonOptions): T_1 & RegisterSelf<T_1>;
}>;
/**
 * @alpha
 */
export declare const Container: InterfaceSymbol<Container>;
/**
 * @alpha
 */
export declare const ServiceLocator: InterfaceSymbol<ServiceLocator>;
/**
 * @alpha
 */
export declare const inject: (...dependencies: Key[]) => (target: any, key?: string | number | undefined, descriptor?: number | PropertyDescriptor | undefined) => void;
declare function transientDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
/**
 * Registers the decorated class as a transient dependency; each time the dependency is resolved
 * a new instance will be created.
 *
 * @example
 * ```ts
 * &#64;transient()
 * class Foo { }
 * ```
 *
 * @alpha
 */
export declare function transient<T extends Constructable>(): typeof transientDecorator;
/**
 * Registers the `target` class as a transient dependency; each time the dependency is resolved
 * a new instance will be created.
 *
 * @param target - The class / constructor function to register as transient.
 *
 * @example
 * ```ts
 * &#64;transient()
 * class Foo { }
 * ```
 *
 * @alpha
 */
export declare function transient<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
declare type SingletonOptions = {
    scoped: boolean;
};
declare function singletonDecorator<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
/**
 * Registers the decorated class as a singleton dependency; the class will only be created once. Each
 * consecutive time the dependency is resolved, the same instance will be returned.
 *
 * @example
 * ```ts
 * &#64;singleton()
 * class Foo { }
 * ```
 *
 * @alpha
 */
export declare function singleton<T extends Constructable>(): typeof singletonDecorator;
/**
 * @alpha
 */
export declare function singleton<T extends Constructable>(options?: SingletonOptions): typeof singletonDecorator;
/**
 * Registers the `target` class as a singleton dependency; the class will only be created once. Each
 * consecutive time the dependency is resolved, the same instance will be returned.
 *
 * @param target - The class / constructor function to register as a singleton.
 *
 * @example
 * ```ts
 * &#64;singleton()
 * class Foo { }
 * ```
 *
 * @alpha
 */
export declare function singleton<T extends Constructable>(target: T & Partial<RegisterSelf<T>>): T & RegisterSelf<T>;
/**
 * @alpha
 */
export declare const all: (key: any, searchAncestors?: boolean | undefined) => ReturnType<typeof DI.inject>;
/**
 * Lazily inject a dependency depending on whether the [[`Key`]] is present at the time of function call.
 *
 * You need to make your argument a function that returns the type, for example
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => number )
 * }
 * const foo = container.get(Foo); // instanceof Foo
 * foo.random(); // throws
 * ```
 * would throw an exception because you haven't registered `'random'` before calling the method. This, would give you a
 * new [['Math.random()']] number each time.
 * ```ts
 * class Foo {
 *   constructor( @lazy('random') public random: () => random )
 * }
 * container.register(Registration.callback('random', Math.random ));
 * container.get(Foo).random(); // some random number
 * container.get(Foo).random(); // another random number
 * ```
 * `@lazy` does not manage the lifecycle of the underlying key. If you want a singleton, you have to register as a
 * `singleton`, `transient` would also behave as you would expect, providing you a new instance each time.
 *
 * @param key - [[`Key`]]
 * see {@link DI.createInterface} on interactions with interfaces
 *
 * @alpha
 */
export declare const lazy: (key: any) => any;
/**
 * Allows you to optionally inject a dependency depending on whether the [[`Key`]] is present, for example
 * ```ts
 * class Foo {
 *   constructor( @inject('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo); // throws
 * ```
 * would fail
 * ```ts
 * class Foo {
 *   constructor( @optional('mystring') public str: string = 'somestring' )
 * }
 * container.get(Foo).str // somestring
 * ```
 * if you use it without a default it will inject `undefined`, so rember to mark your input type as
 * possibly `undefined`!
 *
 * @param key - [[`Key`]]
 *
 * see {@link DI.createInterface} on interactions with interfaces
 *
 * @alpha
 */
export declare const optional: (key: any) => any;
/**
 * Ignore tells the container not to try to inject a dependency.
 *
 * @alpha
 */
export declare function ignore(target: Injectable, property?: string | number, descriptor?: PropertyDescriptor | number): void;
/**
 * @alpha
 */
export declare const newInstanceForScope: (key: any) => any;
/**
 * @alpha
 */
export declare const newInstanceOf: (key: any) => any;
/** @internal */
export declare const enum ResolverStrategy {
    instance = 0,
    singleton = 1,
    transient = 2,
    callback = 3,
    array = 4,
    alias = 5
}
/** @internal */
export declare class ResolverImpl implements Resolver, Registration {
    key: Key;
    strategy: ResolverStrategy;
    state: any;
    constructor(key: Key, strategy: ResolverStrategy, state: any);
    get $isResolver(): true;
    private resolving;
    register(container: Container, key?: Key): Resolver;
    resolve(handler: Container, requestor: Container): any;
    getFactory(container: Container): Factory | null;
}
/**
 * @alpha
 */
export interface Invoker<T extends Constructable = any> {
    invoke(container: Container, fn: T, dependencies: Key[]): Resolved<T>;
    invokeWithDynamicDependencies(container: Container, fn: T, staticDependencies: Key[], dynamicDependencies: Key[]): Resolved<T>;
}
/** @internal */
export declare class FactoryImpl<T extends Constructable = any> implements Factory<T> {
    Type: T;
    private readonly dependencies;
    private transformers;
    constructor(Type: T, dependencies: Key[]);
    construct(container: Container, dynamicDependencies?: Key[]): Resolved<T>;
    registerTransformer(transformer: (instance: any) => any): void;
}
/**
 * @alpha
 */
export declare class ContainerImpl implements Container {
    protected owner: any;
    protected config: ContainerConfiguration;
    private _parent;
    private registerDepth;
    private resolvers;
    get parent(): ContainerImpl | null;
    get depth(): number;
    get responsibleForOwnerRequests(): boolean;
    constructor(owner: any, config: ContainerConfiguration);
    register(...params: any[]): Container;
    registerResolver<K extends Key, T = K>(key: K, resolver: Resolver<T>): Resolver<T>;
    registerTransformer<K extends Key, T = K>(key: K, transformer: Transformer<T>): boolean;
    getResolver<K extends Key, T = K>(key: K | Key, autoRegister?: boolean): Resolver<T> | null;
    has<K extends Key>(key: K, searchAncestors?: boolean): boolean;
    get<K extends Key>(key: K): Resolved<K>;
    getAll<K extends Key>(key: K, searchAncestors?: boolean): readonly Resolved<K>[];
    getFactory<K extends Constructable>(Type: K): Factory<K>;
    registerFactory<K extends Constructable>(key: K, factory: Factory<K>): void;
    createChild(config?: Partial<Omit<ContainerConfiguration, "parentLocator">>): Container;
    private jitRegister;
}
/**
 * You can use the resulting Registration of any of the factory methods
 * to register with the container, e.g.
 * ```
 * class Foo {}
 * const container = DI.createContainer();
 * container.register(Registration.instance(Foo, new Foo()));
 * container.get(Foo);
 * ```
 *
 * @alpha
 */
export declare const Registration: Readonly<{
    /**
     * allows you to pass an instance.
     * Every time you request this {@link Key} you will get this instance back.
     * ```
     * Registration.instance(Foo, new Foo()));
     * ```
     *
     * @param key -
     * @param value -
     */
    instance<T>(key: Key, value: T): Registration<T>;
    /**
     * Creates an instance from the class.
     * Every time you request this {@link Key} you will get the same one back.
     * ```
     * Registration.singleton(Foo, Foo);
     * ```
     *
     * @param key -
     * @param value -
     */
    singleton<T_1 extends Constructable<{}>>(key: Key, value: T_1): Registration<InstanceType<T_1>>;
    /**
     * Creates an instance from a class.
     * Every time you request this {@link Key} you will get a new instance.
     * ```
     * Registration.instance(Foo, Foo);
     * ```
     *
     * @param key -
     * @param value -
     */
    transient<T_2 extends Constructable<{}>>(key: Key, value: T_2): Registration<InstanceType<T_2>>;
    /**
     * Creates an instance from the method passed.
     * Every time you request this {@link Key} you will get a new instance.
     * ```
     * Registration.callback(Foo, () => new Foo());
     * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key -
     * @param callback -
     */
    callback<T_3>(key: Key, callback: ResolveCallback<T_3>): Registration<Resolved<T_3>>;
    /**
     * Creates an instance from the method passed.
     * On the first request for the {@link Key} your callback is called and returns an instance.
     * subsequent requests for the {@link Key}, the initial instance returned will be returned.
     * If you pass the same Registration to another container the same cached value will be used.
     * Should all references to the resolver returned be removed, the cache will expire.
     * ```
     * Registration.cachedCallback(Foo, () => new Foo());
     * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
     * ```
     *
     * @param key -
     * @param callback -
     */
    cachedCallback<T_4>(key: Key, callback: ResolveCallback<T_4>): Registration<Resolved<T_4>>;
    /**
     * creates an alternate {@link Key} to retrieve an instance by.
     * Returns the same scope as the original {@link Key}.
     * ```
     * Register.singleton(Foo, Foo)
     * Register.aliasTo(Foo, MyFoos);
     *
     * container.getAll(MyFoos) // contains an instance of Foo
     * ```
     *
     * @param originalKey -
     * @param aliasKey -
     */
    aliasTo<T_5>(originalKey: T_5, aliasKey: Key): Registration<Resolved<T_5>>;
}>;
/** @internal */
export declare function validateKey(key: any): void;
/**
 * @alpha
 */
export interface DOMParentLocatorEventDetail {
    container: Container | void;
}
export {};
