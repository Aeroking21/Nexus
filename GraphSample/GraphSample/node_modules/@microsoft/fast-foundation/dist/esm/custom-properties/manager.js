import { __decorate } from "tslib";
import { DOM, ElementStyles, Observable, observable, } from "@microsoft/fast-element";
const hostSelector = ":host{}";
class CustomPropertyManagerBase {
    constructor() {
        /**
         * A queue of additions and deletions. Operations will be queued when customPropertyTarget is null
         */
        this.queue = new Set();
        /**
         * The CSSStyleDeclaration to which all CSS custom properties are written
         */
        this.customPropertyTarget = null;
        /**
         * The private settable owner
         */
        this._owner = null;
        /**
         * Tracks state of rAF to only invoke property writes once per animation frame
         */
        this.ticking = false;
        /**
         * Stores all CSSCustomPropertyDefinitions registered with the provider.
         */
        this.cssCustomPropertyDefinitions = new Map();
    }
    /**
     * {@inheritdoc CustomPropertyManager.owner}
     */
    get owner() {
        return this._owner;
    }
    /**
     * {@inheritdoc CustomPropertyManager.register}
     */
    register(def) {
        const cached = this.cssCustomPropertyDefinitions.get(def.name);
        if (cached) {
            cached.count += 1;
        }
        else {
            this.cssCustomPropertyDefinitions.set(def.name, Object.assign(Object.assign({}, def), { count: 1 }));
            this.set(def);
        }
    }
    /**
     * {@inheritdoc CustomPropertyManager.unregister}
     */
    unregister(name) {
        const cached = this.cssCustomPropertyDefinitions.get(name);
        if (cached) {
            cached.count -= 1;
            if (cached.count === 0) {
                this.cssCustomPropertyDefinitions.delete(name);
                this.remove(name);
            }
        }
    }
    /**
     * {@inheritdoc CustomPropertyManager.set}
     */
    set(definition) {
        if (this.owner) {
            this.customPropertyTarget
                ? this.customPropertyTarget.setProperty(`--${definition.name}`, this.owner.evaluate(definition))
                : this.queue.add(this.set.bind(this, definition));
        }
    }
    /**
     * Removes a CSS custom property from the provider.
     * @param name - the name of the property to remove
     */
    remove(name) {
        this.customPropertyTarget
            ? this.customPropertyTarget.removeProperty(`--${name}`)
            : this.queue.add(this.remove.bind(this, name));
    }
    /**
     * {@inheritdoc CustomPropertyManager.setAll}
     */
    setAll() {
        if (this.ticking) {
            return;
        }
        this.ticking = true;
        DOM.queueUpdate(() => {
            this.ticking = false;
            this.cssCustomPropertyDefinitions.forEach(def => {
                this.set(def);
            });
        });
    }
}
/**
 * An implementation of {@link CustomPropertyManager} that uses the constructable CSSStyleSheet object.
 * This implementation supports multiple CustomPropertyManagerTarget subscriptions.
 *
 * @public
 */
export class ConstructableStylesCustomPropertyManager extends CustomPropertyManagerBase {
    constructor(sheet) {
        super();
        this.subscribers = new Set();
        this.sheet = sheet;
        this.styles = ElementStyles.create([sheet]);
        this.customPropertyTarget = sheet.cssRules[sheet.insertRule(hostSelector)].style;
    }
    /**
     * {@inheritdoc CustomPropertyManager.subscribe}
     */
    subscribe(client) {
        this.subscribers.add(client);
        if (this.subscribers.size === 1) {
            this._owner = client;
        }
        client.cssCustomPropertyDefinitions.forEach(def => {
            this.register(def);
        });
        client.$fastController.addStyles(this.styles);
    }
    /**
     * {@inheritdoc CustomPropertyManager.unsubscribe}
     */
    unsubscribe(client) {
        this.subscribers.delete(client);
        client.cssCustomPropertyDefinitions.forEach(def => this.unregister(def.name));
        if (this.owner === client) {
            this._owner = this.subscribers.size
                ? this.subscribers.values().next().value
                : null;
        }
        if (!this.sheet.ownerNode && this.styles) {
            client.$fastController.removeStyles(this.styles);
        }
    }
    /**
     * {@inheritdoc CustomPropertyManager.isSubscribed}
     */
    isSubscribed(client) {
        return this.subscribers.has(client);
    }
}
/**
 * An implementation of {@link CustomPropertyManager} that uses the HTMLStyleElement. This implementation
 * does not support multiple CustomPropertyManagerTarget subscriptions.
 *
 * @public
 */
export class StyleElementCustomPropertyManager extends CustomPropertyManagerBase {
    constructor(style, client) {
        super();
        this._sheet = null;
        this.handleConnection = {
            handleChange: () => {
                var _a;
                this._sheet = this.styles.sheet;
                const key = this.sheet.insertRule(hostSelector);
                this.customPropertyTarget = this.sheet.rules[key].style;
                Observable.getNotifier((_a = this._owner) === null || _a === void 0 ? void 0 : _a.$fastController).unsubscribe(this.handleConnection, "isConnected");
            },
        };
        const controller = client.$fastController;
        // For HTMLStyleElements we need to attach the element
        // to the DOM prior to accessing the HTMLStyleElement.sheet
        // because the property evaluates null if disconnected
        controller.addStyles(style);
        this.styles = style;
        this._owner = client;
        // If the element isn't connected when the manager is created, the sheet can be null.
        // In those cases, set up notifier for when the element is connected and set up the customPropertyTarget
        // then.
        client.isConnected
            ? this.handleConnection.handleChange()
            : Observable.getNotifier(controller).subscribe(this.handleConnection, "isConnected");
        client.cssCustomPropertyDefinitions.forEach(def => {
            this.register(def);
        });
    }
    get sheet() {
        return this._sheet;
    }
    customPropertyTargetChanged(prev, next) {
        if (!prev && this.queue.size) {
            this.queue.forEach(fn => fn());
            this.queue.clear();
        }
    }
}
__decorate([
    observable
], StyleElementCustomPropertyManager.prototype, "customPropertyTarget", void 0);
