import { __decorate } from "tslib";
import { FASTElement, observable } from "@microsoft/fast-element";
import { ComponentPresentation, DefaultComponentPresentation, DesignSystemRegistrationContext, } from "../design-system";
import { Container, Registration } from "../di";
/**
 * Defines a foundation element class that:
 * 1. Connects the element to its ComponentPresentation
 * 2. Allows resolving the element template from the instance or ComponentPresentation
 * 3. Allows resolving the element styles from the instance or ComponentPresentation
 *
 * @alpha
 */
export class FoundationElement extends FASTElement {
    constructor() {
        super(...arguments);
        this._presentation = null;
    }
    /**
     * A property which resolves the ComponentPresentation instance
     * for the current component.
     */
    get $presentation() {
        if (this._presentation === null) {
            this._presentation = this.container.get(ComponentPresentation.keyFrom(this.tagName));
        }
        return this._presentation;
    }
    templateChanged() {
        if (this.template !== undefined) {
            this.$fastController.template = this.template;
        }
    }
    stylesChanged() {
        if (this.styles !== undefined) {
            this.$fastController.styles = this.styles;
        }
    }
    /**
     * The connected callback for this FASTElement.
     * @remarks
     * This method is invoked by the platform whenever this FoundationElement
     * becomes connected to the document.
     */
    connectedCallback() {
        this.$presentation.applyTo(this);
        super.connectedCallback();
    }
    /**
     * Defines an element registry function with a set of element definition defaults.
     * @param elementDefinition - The definition of the element to create the registry
     * function for.
     */
    static compose(elementDefinition) {
        return (overrideDefinition = {}) => new FoundationElementRegistry(this === FoundationElement ? class extends FoundationElement {
        } : this, elementDefinition, overrideDefinition);
    }
}
__decorate([
    Container
], FoundationElement.prototype, "container", void 0);
__decorate([
    observable
], FoundationElement.prototype, "template", void 0);
__decorate([
    observable
], FoundationElement.prototype, "styles", void 0);
function resolveOption(option, context, definition) {
    if (typeof option === "function") {
        return option(context, definition);
    }
    return option;
}
class FoundationElementRegistry {
    constructor(type, elementDefinition, overrideDefinition) {
        this.type = type;
        this.elementDefinition = elementDefinition;
        this.overrideDefinition = overrideDefinition;
    }
    register(container) {
        const definition = Object.assign(Object.assign({}, this.elementDefinition), this.overrideDefinition);
        const context = container.get(DesignSystemRegistrationContext);
        const prefix = definition.prefix || context.elementPrefix;
        const name = `${prefix}-${definition.baseName}`;
        context.tryDefineElement(name, this.type, x => {
            const presentation = new DefaultComponentPresentation(resolveOption(definition.template, x, definition), resolveOption(definition.styles, x, definition));
            x.container.register(Registration.instance(ComponentPresentation.keyFrom(x.name), presentation));
            x.defineElement({
                elementOptions: resolveOption(definition.elementOptions, x, definition),
                shadowOptions: resolveOption(definition.shadowOptions, x, definition),
                attributes: resolveOption(definition.attributes, x, definition),
            });
        });
    }
}
