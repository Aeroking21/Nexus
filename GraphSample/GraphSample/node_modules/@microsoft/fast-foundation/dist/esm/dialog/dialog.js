import { __decorate } from "tslib";
import { attr, DOM, FASTElement } from "@microsoft/fast-element";
import { keyCodeEscape, keyCodeTab } from "@microsoft/fast-web-utilities";
import { tabbable } from "tabbable";
/**
 * A Switch Custom HTML Element.
 * Implements the {@link https://www.w3.org/TR/wai-aria-1.1/#dialog | ARIA dialog }.
 *
 * @public
 */
export class Dialog extends FASTElement {
    constructor() {
        super(...arguments);
        /**
         * Indicates the element is modal. When modal, user interaction will be limited to the contents of the element.
         * @public
         * @defaultValue - true
         * @remarks
         * HTML Attribute: modal
         */
        this.modal = true;
        /**
         * The hidden state of the element.
         *
         * @public
         * @defaultValue - false
         * @remarks
         * HTML Attribute: hidden
         */
        this.hidden = false;
        /**
         * Indicates that the dialog should trap focus.
         *
         * @public
         * @defaultValue - true
         * @remarks
         * HTML Attribute: trap-focus
         */
        this.trapFocus = true;
        this.onChildListChange = (mutations) => {
            if (mutations.length) {
                this.tabbableElements = tabbable(this);
            }
        };
        this.trapFocusChanged = () => {
            if (this.trapFocus) {
                // store references to tabbable elements
                this.tabbableElements = tabbable(this);
                // Add an event listener for focusin events if we should be trapping focus
                document.addEventListener("focusin", this.handleDocumentFocus);
                // determine if we should move focus inside the dialog
                if (this.shouldForceFocus(document.activeElement)) {
                    this.focusFirstElement();
                }
            }
            else {
                // remove event listener if we are not trapping focus
                document.removeEventListener("focusin", this.handleDocumentFocus);
            }
        };
        this.handleDocumentKeydown = (e) => {
            if (!e.defaultPrevented && !this.hidden) {
                switch (e.keyCode) {
                    case keyCodeEscape:
                        this.dismiss();
                        break;
                    case keyCodeTab:
                        this.handleTabKeyDown(e);
                        break;
                }
            }
        };
        this.handleDocumentFocus = (e) => {
            if (!e.defaultPrevented && this.shouldForceFocus(e.target)) {
                this.focusFirstElement();
                e.preventDefault();
            }
        };
        this.handleTabKeyDown = (e) => {
            if (!this.trapFocus) {
                return;
            }
            const tabbableElementCount = this.tabbableElements.length;
            if (tabbableElementCount === 0) {
                this.dialog.focus();
                e.preventDefault();
                return;
            }
            if (e.shiftKey && e.target === this.tabbableElements[0]) {
                this.tabbableElements[tabbableElementCount - 1].focus();
                e.preventDefault();
            }
            else if (!e.shiftKey &&
                e.target === this.tabbableElements[tabbableElementCount - 1]) {
                this.tabbableElements[0].focus();
                e.preventDefault();
            }
        };
        /**
         * focus on first element of tab queue
         */
        this.focusFirstElement = () => {
            if (this.tabbableElements.length === 0) {
                this.dialog.focus();
            }
            else {
                this.tabbableElements[0].focus();
            }
        };
        /**
         * we should only focus if focus has not already been brought to the dialog
         */
        this.shouldForceFocus = (currentFocusElement) => {
            return !this.hidden && !this.contains(currentFocusElement);
        };
    }
    /**
     * @internal
     */
    dismiss() {
        this.$emit("dismiss");
    }
    /**
     * The method to show the dialog.
     *
     * @public
     */
    show() {
        this.hidden = false;
    }
    /**
     * The method to hide the dialog.
     *
     * @public
     */
    hide() {
        this.hidden = true;
    }
    /**
     * @internal
     */
    connectedCallback() {
        super.connectedCallback();
        this.observer = new MutationObserver(this.onChildListChange);
        // only observe if nodes are added or removed
        this.observer.observe(this, { childList: true });
        document.addEventListener("keydown", this.handleDocumentKeydown);
        // Ensure the DOM is updated
        // This helps avoid a delay with `autofocus` elements receiving focus
        DOM.queueUpdate(this.trapFocusChanged);
    }
    /**
     * @internal
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        // disconnect observer
        this.observer.disconnect();
        // remove keydown event listener
        document.removeEventListener("keydown", this.handleDocumentKeydown);
        // if we are trapping focus remove the focusin listener
        if (this.trapFocus) {
            document.removeEventListener("focusin", this.handleDocumentFocus);
        }
    }
}
__decorate([
    attr({ mode: "boolean" })
], Dialog.prototype, "modal", void 0);
__decorate([
    attr({ mode: "boolean" })
], Dialog.prototype, "hidden", void 0);
__decorate([
    attr({ attribute: "trap-focus", mode: "boolean" })
], Dialog.prototype, "trapFocus", void 0);
__decorate([
    attr({ attribute: "aria-describedby" })
], Dialog.prototype, "ariaDescribedby", void 0);
__decorate([
    attr({ attribute: "aria-labelledby" })
], Dialog.prototype, "ariaLabelledby", void 0);
__decorate([
    attr({ attribute: "aria-label" })
], Dialog.prototype, "ariaLabel", void 0);
