import { FASTElementDefinition, } from "@microsoft/fast-element";
import { DI, Registration } from "../di/di";
/**
 * @alpha
 */
export const DesignSystemRegistrationContext = DI.createInterface();
const elementTypesByTag = new Map();
const elementTagsByType = new Map();
/**
 * @alpha
 */
export class DesignSystem {
    constructor() {
        this.registrations = [];
        this.prefix = "fast";
        this.disambiguate = () => null;
    }
    withPrefix(prefix) {
        this.prefix = prefix;
        return this;
    }
    withElementDisambiguation(callback) {
        this.disambiguate = callback;
        return this;
    }
    register(...params) {
        this.registrations.push(...params);
        return this;
    }
    applyTo(element) {
        const container = DI.getOrCreateDOMContainer(element);
        const elementDefinitionEntries = [];
        const disambiguate = this.disambiguate;
        const context = {
            elementPrefix: this.prefix,
            tryDefineElement(name, type, callback) {
                let elementName = name;
                let foundByName = elementTypesByTag.get(elementName);
                while (foundByName && elementName) {
                    elementName = disambiguate(elementName, type, foundByName);
                    if (elementName) {
                        foundByName = elementTypesByTag.get(elementName);
                    }
                }
                const willDefine = !!elementName;
                if (willDefine) {
                    if (elementTagsByType.has(type)) {
                        type = class extends type {
                        };
                    }
                    elementTypesByTag.set(elementName, type);
                    elementTagsByType.set(type, elementName);
                }
                elementDefinitionEntries.push(new ElementDefinitionEntry(container, elementName || name, type, callback, willDefine));
            },
        };
        container.register(Registration.instance(DesignSystemRegistrationContext, context));
        container.register(...this.registrations);
        for (const entry of elementDefinitionEntries) {
            entry.callback(entry);
            if (entry.willDefine && entry.definition !== null) {
                entry.definition.define();
            }
        }
        return container;
    }
}
class ElementDefinitionEntry {
    constructor(container, name, type, callback, willDefine) {
        this.container = container;
        this.name = name;
        this.type = type;
        this.callback = callback;
        this.willDefine = willDefine;
        this.definition = null;
    }
    defineElement(definition) {
        this.definition = new FASTElementDefinition(this.type, Object.assign(Object.assign({}, definition), { name: this.name }));
    }
    tagFor(type) {
        return elementTagsByType.get(type);
    }
}
