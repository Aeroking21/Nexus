{"version":3,"file":"graph.groups.js","sourceRoot":"src/","sources":["graph/graph.groups.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\nimport { IGraph, prepScopes, CacheItem, CacheService, CacheStore } from '@microsoft/mgt-element';\nimport { Group } from '@microsoft/microsoft-graph-types';\nimport { schemas } from './cacheStores';\n\n/**\n * Group Type enumeration\n *\n * @export\n * @enum {number}\n */\nexport enum GroupType {\n  /**\n   * Any group Type\n   */\n  any = 0,\n\n  /**\n   * Office 365 group\n   */\n  // tslint:disable-next-line:no-bitwise\n  unified = 1 << 0,\n\n  /**\n   * Security group\n   */\n  // tslint:disable-next-line:no-bitwise\n  security = 1 << 1,\n\n  /**\n   * Mail Enabled Security group\n   */\n  // tslint:disable-next-line:no-bitwise\n  mailenabledsecurity = 1 << 2,\n\n  /**\n   * Distribution Group\n   */\n  // tslint:disable-next-line:no-bitwise\n  distribution = 1 << 3\n}\n\n/**\n * Object to be stored in cache\n */\nexport interface CacheGroup extends CacheItem {\n  /**\n   * stringified json representing a user\n   */\n  group?: string;\n}\n\n/**\n * Object to be stored in cache representing individual people\n */\ninterface CacheGroupQuery extends CacheItem {\n  /**\n   * json representing a person stored as string\n   */\n  groups?: string[];\n  /**\n   * top number of results\n   */\n  top?: number;\n}\n\n/**\n * Defines the expiration time\n */\nconst getGroupsInvalidationTime = (): number =>\n  CacheService.config.groups.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;\n\n/**\n * Whether the groups store is enabled\n */\nconst getIsGroupsCacheEnabled = (): boolean => CacheService.config.groups.isEnabled && CacheService.config.isEnabled;\n\n/**\n * Searches the Graph for Groups\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport async function findGroups(\n  graph: IGraph,\n  query: string,\n  top: number = 10,\n  groupTypes: GroupType = GroupType.any,\n  groupFilters: string = ''\n): Promise<Group[]> {\n  const scopes = 'Group.Read.All';\n\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${query ? query : '*'}*${groupTypes}*${groupFilters}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x)).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  let filterQuery = '';\n  let responses;\n  let batchedResult = [];\n\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (groupFilters) {\n    filterQuery += `${query ? ' and ' : ''}${groupFilters}`;\n  }\n\n  if (groupTypes !== GroupType.any) {\n    const batch = graph.createBatch();\n\n    const filterGroups = [];\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.unified === (groupTypes & GroupType.unified)) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.security === (groupTypes & GroupType.security)) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.distribution === (groupTypes & GroupType.distribution)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery = filterQuery ? `${filterQuery} and ` : '';\n    for (let filter of filterGroups) {\n      batch.get(filter, `/groups?$filter=${filterQuery + filter}`, ['Group.Read.All']);\n    }\n\n    try {\n      responses = await batch.executeAll();\n\n      for (let i = 0; i < filterGroups.length; i++) {\n        if (responses.get(filterGroups[i]).content.value) {\n          for (let group of responses.get(filterGroups[i]).content.value) {\n            let repeat = batchedResult.filter(batchedGroup => batchedGroup.id === group.id);\n            if (repeat.length === 0) {\n              batchedResult.push(group);\n            }\n            repeat = [];\n          }\n        }\n      }\n    } catch (_) {\n      try {\n        let queries = [];\n        for (let filter of filterGroups) {\n          queries.push(\n            await graph\n              .api('groups')\n              .filter(`${filterQuery} and ${filter}`)\n              .top(top)\n              .count(true)\n              .header('ConsistencyLevel', 'eventual')\n              .middlewareOptions(prepScopes(scopes))\n              .get()\n          );\n        }\n        return Promise.all(queries);\n      } catch (_) {\n        return [];\n      }\n    }\n  } else {\n    if (batchedResult.length === 0) {\n      const result = await graph\n        .api('groups')\n        .filter(filterQuery)\n        .top(top)\n        .count(true)\n        .header('ConsistencyLevel', 'eventual')\n        .middlewareOptions(prepScopes(scopes))\n        .get();\n      if (getIsGroupsCacheEnabled() && result) {\n        cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top: top });\n      }\n      return result ? result.value : null;\n    }\n  }\n\n  return batchedResult;\n}\n\n/**\n * Searches the Graph for group members\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {string} groupId - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members\n * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport async function findGroupsFromGroup(\n  graph: IGraph,\n  query: string,\n  groupId: string,\n  top: number = 10,\n  transitive: boolean = false,\n  groupTypes: GroupType = GroupType.any\n): Promise<Group[]> {\n  const scopes = 'Group.Read.All';\n\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${groupId}:${query || '*'}:${groupTypes}:${transitive}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x)).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  const apiUrl = `groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}/microsoft.graph.group`;\n  let filterQuery = '';\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (groupTypes !== GroupType.any) {\n    const filterGroups = [];\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.unified === (groupTypes & GroupType.unified)) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.security === (groupTypes & GroupType.security)) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    // tslint:disable-next-line:no-bitwise\n    if (GroupType.distribution === (groupTypes & GroupType.distribution)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery += (query !== '' ? ' and ' : '') + filterGroups.join(' or ');\n  }\n\n  const result = await graph\n    .api(apiUrl)\n    .filter(filterQuery)\n    .count(true)\n    .top(top)\n    .header('ConsistencyLevel', 'eventual')\n    .middlewareOptions(prepScopes(scopes))\n    .get();\n\n  if (getIsGroupsCacheEnabled() && result) {\n    cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top: top });\n  }\n\n  return result ? result.value : null;\n}\n\n/**\n * async promise, returns all Graph groups associated with the id provided\n *\n * @param {string} id\n * @returns {(Promise<User>)}\n * @memberof Graph\n */\nexport async function getGroup(graph: IGraph, id: string, requestedProps?: string[]): Promise<Group> {\n  const scopes = 'Group.Read.All';\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n    // check cache\n    const group = await cache.getValue(id);\n\n    // is it stored and is timestamp good?\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      const cachedData = group.group ? JSON.parse(group.group) : null;\n      const uniqueProps =\n        requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;\n\n      // return without any worries\n      if (!uniqueProps || uniqueProps.length <= 1) {\n        return cachedData;\n      }\n    }\n  }\n\n  let apiString = `/groups/${id}`;\n  if (requestedProps) {\n    apiString = apiString + '?$select=' + requestedProps.toString();\n  }\n\n  // else we must grab it\n  const response = await graph.api(apiString).middlewareOptions(prepScopes(scopes)).get();\n  if (getIsGroupsCacheEnabled()) {\n    cache.putValue(id, { group: JSON.stringify(response) });\n  }\n  return response;\n}\n\n/**\n * Returns a Promise of Graph Groups array associated with the groupIds array\n *\n * @export\n * @param {IGraph} graph\n * @param {string[]} groupIds, an array of string ids\n * @returns {Promise<Group[]>}\n */\nexport async function getGroupsForGroupIds(graph: IGraph, groupIds: string[], filters: string = ''): Promise<Group[]> {\n  if (!groupIds || groupIds.length === 0) {\n    return [];\n  }\n  const batch = graph.createBatch();\n  const groupDict = {};\n  const notInCache = [];\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n  }\n\n  for (const id of groupIds) {\n    groupDict[id] = null;\n    let group = null;\n    if (getIsGroupsCacheEnabled()) {\n      group = await cache.getValue(id);\n    }\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      groupDict[id] = group.group ? JSON.parse(group.group) : null;\n    } else if (id !== '') {\n      let apiUrl: string = `/groups/${id}`;\n      if (filters) {\n        apiUrl = `${apiUrl}?$filters=${filters}`;\n      }\n      batch.get(id, apiUrl, ['Group.Read.All']);\n      notInCache.push(id);\n    }\n  }\n  try {\n    const responses = await batch.executeAll();\n    // iterate over groupIds to ensure the order of ids\n    for (const id of groupIds) {\n      const response = responses.get(id);\n      if (response && response.content) {\n        groupDict[id] = response.content;\n        if (getIsGroupsCacheEnabled()) {\n          cache.putValue(id, { group: JSON.stringify(response.content) });\n        }\n      }\n    }\n    return Promise.all(Object.values(groupDict));\n  } catch (_) {\n    // fallback to making the request one by one\n    try {\n      // call getGroup for all the users that weren't cached\n      groupIds.filter(id => notInCache.includes(id)).forEach(id => (groupDict[id] = getGroup(graph, id)));\n      if (getIsGroupsCacheEnabled()) {\n        // store all users that weren't retrieved from the cache, into the cache\n        groupIds\n          .filter(id => notInCache.includes(id))\n          .forEach(async id => cache.putValue(id, { group: JSON.stringify(await groupDict[id]) }));\n      }\n      return Promise.all(Object.values(groupDict));\n    } catch (_) {\n      return [];\n    }\n  }\n}\n\n/**\n * Gets groups from the graph that are in the group ids\n * @param graph\n * @param query\n * @param groupId\n * @param top\n * @param transitive\n * @param groupTypes\n * @param filters\n * @returns\n */\nexport async function findGroupsFromGroupIds(\n  graph: IGraph,\n  query: string,\n  groupIds: string[],\n  top: number = 10,\n  groupTypes: GroupType = GroupType.any,\n  filters: string = ''\n): Promise<Group[]> {\n  const foundGroups: Group[] = [];\n  const graphGroups = await findGroups(graph, query, top, groupTypes, filters);\n  if (graphGroups) {\n    for (let i = 0; i < graphGroups.length; i++) {\n      const group = graphGroups[i];\n      if (group.id && groupIds.includes(group.id)) {\n        foundGroups.push(group);\n      }\n    }\n  }\n  return foundGroups;\n}\n"]}