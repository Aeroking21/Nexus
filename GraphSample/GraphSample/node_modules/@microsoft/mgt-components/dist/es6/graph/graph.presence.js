/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { schemas } from './cacheStores';
/**
 * Defines the expiration time
 */
const getPresenceInvalidationTime = () => CacheService.config.presence.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether the groups store is enabled
 */
const getIsPresenceCacheEnabled = () => CacheService.config.presence.isEnabled && CacheService.config.isEnabled;
/**
 * async promise, allows developer to get user presence
 *
 * @returns {Promise<Presence>}
 * @param {IGraph} graph
 * @param {string} userId - id for the user or null for current signed in user
 * @memberof BetaGraph
 */
export function getUserPresence(graph, userId) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        if (getIsPresenceCacheEnabled()) {
            cache = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);
            const presence = yield cache.getValue(userId || 'me');
            if (presence && getPresenceInvalidationTime() > Date.now() - presence.timeCached) {
                return JSON.parse(presence.presence);
            }
        }
        const scopes = userId ? ['presence.read.all'] : ['presence.read'];
        const resource = userId ? `/users/${userId}/presence` : '/me/presence';
        const result = yield graph
            .api(resource)
            .middlewareOptions(prepScopes(...scopes))
            .get();
        if (getIsPresenceCacheEnabled()) {
            cache.putValue(userId || 'me', { presence: JSON.stringify(result) });
        }
        return result;
    });
}
/**
 * async promise, allows developer to get person presense by providing array of IDynamicPerson
 *
 * @returns {}
 * @memberof BetaGraph
 */
export function getUsersPresenceByPeople(graph, people) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!people || people.length === 0) {
            return {};
        }
        const peoplePresence = {};
        const peoplePresenceToQuery = [];
        const scopes = ['presence.read.all'];
        let cache;
        if (getIsPresenceCacheEnabled()) {
            cache = CacheService.getCache(schemas.presence, schemas.presence.stores.presence);
        }
        for (const person of people) {
            if (person === null || person === void 0 ? void 0 : person.id) {
                const id = person.id;
                peoplePresence[id] = null;
                let presence;
                if (getIsPresenceCacheEnabled()) {
                    presence = yield cache.getValue(id);
                }
                if (getIsPresenceCacheEnabled() &&
                    presence &&
                    getPresenceInvalidationTime() > Date.now() - (yield presence).timeCached) {
                    peoplePresence[id] = JSON.parse(presence.presence);
                }
                else {
                    peoplePresenceToQuery.push(id);
                }
            }
        }
        try {
            if (peoplePresenceToQuery.length > 0) {
                const presenceResult = yield graph
                    .api('/communications/getPresencesByUserId')
                    .middlewareOptions(prepScopes(...scopes))
                    .post({
                    ids: peoplePresenceToQuery
                });
                for (const r of presenceResult.value) {
                    peoplePresence[r.id] = r;
                    if (getIsPresenceCacheEnabled()) {
                        cache.putValue(r.id, { presence: JSON.stringify(r) });
                    }
                }
            }
            return peoplePresence;
        }
        catch (_) {
            try {
                /**
                 * individual calls to getUserPresence as fallback
                 * must filter out the contacts, which will either 404 or have PresenceUnknown response
                 * caching will be handled by getUserPresence
                 */
                const response = yield Promise.all(people
                    .filter(person => person &&
                    person.id &&
                    !peoplePresence[person.id] &&
                    'personType' in person &&
                    person.personType.subclass === 'OrganizationUser')
                    .map(person => getUserPresence(graph, person.id)));
                for (const r of response) {
                    peoplePresence[r.id] = r;
                }
                return peoplePresence;
            }
            catch (_) {
                return null;
            }
        }
    });
}
//# sourceMappingURL=graph.presence.js.map