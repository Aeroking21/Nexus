/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { extractEmailAddress } from '../utils/Utils';
import { schemas } from './cacheStores';
/**
 * Person Type enum
 *
 * @export
 * @enum {number}
 */
export var PersonType;
(function (PersonType) {
    /**
     * Any type
     */
    PersonType[PersonType["any"] = 0] = "any";
    /**
     * A Person such as User or Contact
     */
    PersonType["person"] = "person";
    /**
     * A group
     */
    PersonType["group"] = "group";
})(PersonType || (PersonType = {}));
/**
 * User Type enum
 *
 * @export
 * @enum {number}
 */
export var UserType;
(function (UserType) {
    /**
     * Any user or contact
     */
    UserType["any"] = "any";
    /**
     * An organization User
     */
    UserType["user"] = "user";
    /**
     * An implicit or personal contact
     */
    UserType["contact"] = "contact";
})(UserType || (UserType = {}));
/**
 * Defines the expiration time
 */
const getPeopleInvalidationTime = () => CacheService.config.people.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether the people store is enabled
 */
const getIsPeopleCacheEnabled = () => CacheService.config.people.isEnabled && CacheService.config.isEnabled;
/**
 * async promise, returns all Graph people who are most relevant contacts to the signed in user.
 *
 * @param {string} query
 * @param {number} [top=10] - number of people to return
 * @param {PersonType} [personType=PersonType.person] - the type of person to search for
 * @returns {(Promise<Person[]>)}
 */
export function findPeople(graph, query, top = 10, userType = UserType.any, filters = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'people.read';
        let cache;
        const cacheKey = `${query}:${top}:${userType}`;
        if (getIsPeopleCacheEnabled()) {
            cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
            const result = getIsPeopleCacheEnabled() ? yield cache.getValue(cacheKey) : null;
            if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
                return result.results.map(peopleStr => JSON.parse(peopleStr));
            }
        }
        let filter = "personType/class eq 'Person'";
        if (userType !== UserType.any) {
            if (userType === UserType.user) {
                filter += "and personType/subclass eq 'OrganizationUser'";
            }
            else {
                filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
            }
        }
        if (filters !== '') {
            // Adding the default people filters to the search filters
            filter += `${filter} and ${filters}`;
        }
        let graphResult;
        try {
            let graphRequest = graph
                .api('/me/people')
                .search('"' + query + '"')
                .top(top)
                .filter(filter)
                .middlewareOptions(prepScopes(scopes));
            if (userType !== UserType.contact) {
                // for any type other than Contact, user a wider search
                graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
            }
            graphResult = yield graphRequest.get();
            if (getIsPeopleCacheEnabled() && graphResult) {
                const item = { maxResults: top, results: null };
                item.results = graphResult.value.map(personStr => JSON.stringify(personStr));
                cache.putValue(cacheKey, item);
            }
        }
        catch (error) {
            // intentionally empty
        }
        return graphResult ? graphResult.value : null;
    });
}
/**
 * async promise to the Graph for People, by default, it will request the most frequent contacts for the signed in user.
 *
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export function getPeople(graph, userType = UserType.any, peopleFilters = '') {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'people.read';
        let cache;
        const cacheKey = peopleFilters ? peopleFilters : `*:${userType}`;
        if (getIsPeopleCacheEnabled()) {
            cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
            const cacheRes = yield cache.getValue(cacheKey);
            if (cacheRes && getPeopleInvalidationTime() > Date.now() - cacheRes.timeCached) {
                return cacheRes.results.map(ppl => JSON.parse(ppl));
            }
        }
        const uri = '/me/people';
        let filter = "personType/class eq 'Person'";
        if (userType !== UserType.any) {
            if (userType === UserType.user) {
                filter += "and personType/subclass eq 'OrganizationUser'";
            }
            else {
                filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
            }
        }
        if (peopleFilters) {
            filter += ` and ${peopleFilters}`;
        }
        let people;
        try {
            let graphRequest = graph.api(uri).middlewareOptions(prepScopes(scopes)).filter(filter);
            if (userType != UserType.contact) {
                // for any type other than Contact, user a wider search
                graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
            }
            people = yield graphRequest.get();
            if (getIsPeopleCacheEnabled() && people) {
                cache.putValue(cacheKey, { maxResults: 10, results: people.value.map(ppl => JSON.stringify(ppl)) });
            }
        }
        catch (_) { }
        return people ? people.value : null;
    });
}
/**
 * returns a promise that resolves after specified time
 * @param time in milliseconds
 */
export function getEmailFromGraphEntity(entity) {
    const person = entity;
    const user = entity;
    const contact = entity;
    if (user.mail) {
        return extractEmailAddress(user.mail);
    }
    else if (person.scoredEmailAddresses && person.scoredEmailAddresses.length) {
        return extractEmailAddress(person.scoredEmailAddresses[0].address);
    }
    else if (contact.emailAddresses && contact.emailAddresses.length) {
        return extractEmailAddress(contact.emailAddresses[0].address);
    }
    return null;
}
/**
 * async promise, returns a Graph contact associated with the email provided
 *
 * @param {string} email
 * @returns {(Promise<Contact[]>)}
 * @memberof Graph
 */
export function findContactsByEmail(graph, email) {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'contacts.read';
        let cache;
        if (getIsPeopleCacheEnabled()) {
            cache = CacheService.getCache(schemas.people, schemas.people.stores.contacts);
            const contact = yield cache.getValue(email);
            if (contact && getPeopleInvalidationTime() > Date.now() - contact.timeCached) {
                return JSON.parse(contact.person);
            }
        }
        const encodedEmail = `${email.replace(/#/g, '%2523')}`;
        const result = yield graph
            .api('/me/contacts')
            .filter(`emailAddresses/any(a:a/address eq '${encodedEmail}')`)
            .middlewareOptions(prepScopes(scopes))
            .get();
        if (getIsPeopleCacheEnabled() && result) {
            cache.putValue(email, { person: JSON.stringify(result.value) });
        }
        return result ? result.value : null;
    });
}
/**
 * async promise, returns Graph people matching the Graph query specified
 * in the resource param
 *
 * @param {string} resource
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export function getPeopleFromResource(graph, version, resource, scopes) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        const key = `${version}${resource}`;
        if (getIsPeopleCacheEnabled()) {
            cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
            const result = yield cache.getValue(key);
            if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
                return result.results.map(peopleStr => JSON.parse(peopleStr));
            }
        }
        let request = graph.api(resource).version(version);
        if (scopes && scopes.length) {
            request = request.middlewareOptions(prepScopes(...scopes));
        }
        let response = yield request.get();
        // get more pages if there are available
        if (response && Array.isArray(response.value) && response['@odata.nextLink']) {
            let pageCount = 1;
            let page = response;
            while (page && page['@odata.nextLink']) {
                pageCount++;
                const nextResource = page['@odata.nextLink'].split(version)[1];
                page = yield graph.client.api(nextResource).version(version).get();
                if (page && page.value && page.value.length) {
                    page.value = response.value.concat(page.value);
                    response = page;
                }
            }
        }
        if (getIsPeopleCacheEnabled() && response) {
            const item = { results: null };
            if (Array.isArray(response.value)) {
                item.results = response.value.map(personStr => JSON.stringify(personStr));
            }
            else {
                item.results = [JSON.stringify(response)];
            }
            cache.putValue(key, item);
        }
        if (response) {
            return Array.isArray(response.value) ? response.value : [response];
        }
        else {
            return null;
        }
    });
}
//# sourceMappingURL=graph.people.js.map