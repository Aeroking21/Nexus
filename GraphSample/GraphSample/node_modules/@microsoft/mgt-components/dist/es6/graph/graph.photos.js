/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { ResponseType } from '@microsoft/microsoft-graph-client';
import { blobToBase64 } from '../utils/Utils';
import { schemas } from './cacheStores';
import { findContactsByEmail, getEmailFromGraphEntity } from './graph.people';
import { findUsers } from './graph.user';
/**
 * Defines expiration time
 */
export const getPhotoInvalidationTime = () => CacheService.config.photos.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether photo store is enabled
 */
export const getIsPhotosCacheEnabled = () => CacheService.config.photos.isEnabled && CacheService.config.isEnabled;
/**
 * retrieves a photo for the specified resource.
 *
 * @param {string} resource
 * @param {string[]} scopes
 * @returns {Promise<string>}
 */
export function getPhotoForResource(graph, resource, scopes) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = (yield graph
                .api(`${resource}/photo/$value`)
                .responseType(ResponseType.RAW)
                .middlewareOptions(prepScopes(...scopes))
                .get());
            if (response.status === 404) {
                // 404 means the resource does not have a photo
                // we still want to cache that state
                // so we return an object that can be cached
                return { eTag: null, photo: null };
            }
            else if (!response.ok) {
                return null;
            }
            const eTag = response.headers.get('eTag');
            const blob = yield blobToBase64(yield response.blob());
            return { eTag, photo: blob };
        }
        catch (e) {
            return null;
        }
    });
}
/**
 * async promise, returns Graph photos associated with contacts of the logged in user
 * @param contactId
 * @returns {Promise<string>}
 * @memberof Graph
 */
export function getContactPhoto(graph, contactId) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        let photoDetails;
        if (getIsPhotosCacheEnabled()) {
            cache = CacheService.getCache(schemas.photos, schemas.photos.stores.contacts);
            photoDetails = yield cache.getValue(contactId);
            if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
                return photoDetails.photo;
            }
        }
        photoDetails = yield getPhotoForResource(graph, `me/contacts/${contactId}`, ['contacts.read']);
        if (getIsPhotosCacheEnabled() && photoDetails) {
            cache.putValue(contactId, photoDetails);
        }
        return photoDetails ? photoDetails.photo : null;
    });
}
/**
 * async promise, returns Graph photo associated with provided userId
 * @param userId
 * @returns {Promise<string>}
 * @memberof Graph
 */
export function getUserPhoto(graph, userId) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        let photoDetails;
        if (getIsPhotosCacheEnabled()) {
            cache = CacheService.getCache(schemas.photos, schemas.photos.stores.users);
            photoDetails = yield cache.getValue(userId);
            if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
                return photoDetails.photo;
            }
            else if (photoDetails) {
                // there is a photo in the cache, but it's stale
                try {
                    const response = yield graph.api(`users/${userId}/photo`).get();
                    if (response &&
                        (response['@odata.mediaEtag'] !== photoDetails.eTag ||
                            (response['@odata.mediaEtag'] === null && response.eTag === null))) {
                        // set photoDetails to null so that photo gets pulled from the graph later
                        photoDetails = null;
                    }
                }
                catch (_a) {
                    return null;
                }
            }
        }
        // if there is a photo in the cache, we got here because it was stale
        photoDetails = photoDetails || (yield getPhotoForResource(graph, `users/${userId}`, ['user.readbasic.all']));
        if (getIsPhotosCacheEnabled() && photoDetails) {
            cache.putValue(userId, photoDetails);
        }
        return photoDetails ? photoDetails.photo : null;
    });
}
/**
 * async promise, returns Graph photo associated with the logged in user
 * @returns {Promise<string>}
 * @memberof Graph
 */
export function myPhoto(graph) {
    return __awaiter(this, void 0, void 0, function* () {
        let cache;
        let photoDetails;
        if (getIsPhotosCacheEnabled()) {
            cache = CacheService.getCache(schemas.photos, schemas.photos.stores.users);
            photoDetails = yield cache.getValue('me');
            if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
                return photoDetails.photo;
            }
        }
        try {
            const response = yield graph.api('me/photo').get();
            if (response &&
                (response['@odata.mediaEtag'] !== photoDetails.eTag ||
                    (response['@odata.mediaEtag'] === null && response.eTag === null))) {
                photoDetails = null;
            }
        }
        catch (_a) {
            return null;
        }
        photoDetails = photoDetails || (yield getPhotoForResource(graph, 'me', ['user.read']));
        if (getIsPhotosCacheEnabled()) {
            cache.putValue('me', photoDetails || {});
        }
        return photoDetails ? photoDetails.photo : null;
    });
}
/**
 * async promise, loads image of user
 *
 * @export
 */
export function getPersonImage(graph, person, useContactsApis = true) {
    return __awaiter(this, void 0, void 0, function* () {
        // handle if person but not user
        if ('personType' in person && person.personType.subclass !== 'OrganizationUser') {
            if (person.personType.subclass === 'PersonalContact' && useContactsApis) {
                // if person is a contact, look for them and their photo in contact api
                const email = getEmailFromGraphEntity(person);
                const contact = yield findContactsByEmail(graph, email);
                if (contact && contact.length && contact[0].id) {
                    return yield getContactPhoto(graph, contact[0].id);
                }
            }
            return null;
        }
        // handle if user
        if (person.userPrincipalName || person.id) {
            // try to find a user by userPrincipalName
            const id = person.userPrincipalName || person.id;
            return yield getUserPhoto(graph, id);
        }
        // else assume id is for user and try to get photo
        if (person.id) {
            const image = yield getUserPhoto(graph, person.id);
            if (image) {
                return image;
            }
        }
        // let's try to find a person by the email
        const email = getEmailFromGraphEntity(person);
        if (email) {
            // try to find user
            const users = yield findUsers(graph, email, 1);
            if (users && users.length) {
                return yield getUserPhoto(graph, users[0].id);
            }
            // if no user, try to find a contact
            if (useContactsApis) {
                const contacts = yield findContactsByEmail(graph, email);
                if (contacts && contacts.length) {
                    return yield getContactPhoto(graph, contacts[0].id);
                }
            }
        }
        return null;
    });
}
export function getGroupImage(graph, group, useContactsApis = true) {
    return __awaiter(this, void 0, void 0, function* () {
        let photoDetails;
        let cache;
        let groupId = group.id;
        if (getIsPhotosCacheEnabled()) {
            cache = CacheService.getCache(schemas.photos, schemas.photos.stores.groups);
            photoDetails = yield cache.getValue(groupId);
            if (photoDetails && getPhotoInvalidationTime() > Date.now() - photoDetails.timeCached) {
                return photoDetails.photo;
            }
            else if (photoDetails) {
                // there is a photo in the cache, but it's stale
                try {
                    const response = yield graph.api(`groups/${groupId}/photo`).get();
                    if (response &&
                        (response['@odata.mediaEtag'] !== photoDetails.eTag ||
                            (response['@odata.mediaEtag'] === null && response.eTag === null))) {
                        // set photoDetails to null so that photo gets pulled from the graph later
                        photoDetails = null;
                    }
                }
                catch (_a) {
                    return null;
                }
            }
        }
        // if there is a photo in the cache, we got here because it was stale
        photoDetails = photoDetails || (yield getPhotoForResource(graph, `groups/${groupId}`, ['user.readbasic.all']));
        if (getIsPhotosCacheEnabled() && photoDetails) {
            cache.putValue(groupId, photoDetails);
        }
        return photoDetails ? photoDetails.photo : null;
    });
}
/**
 * checks if user has a photo in the cache
 * @param userId
 * @returns {CachePhoto}
 * @memberof Graph
 */
export function getPhotoFromCache(userId, storeName) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = CacheService.getCache(schemas.photos, storeName);
        const item = yield cache.getValue(userId);
        return item;
    });
}
/**
 * checks if user has a photo in the cache
 * @param userId
 * @returns {void}
 * @memberof Graph
 */
export function storePhotoInCache(userId, storeName, value) {
    return __awaiter(this, void 0, void 0, function* () {
        const cache = CacheService.getCache(schemas.photos, storeName);
        cache.putValue(userId, value);
    });
}
//# sourceMappingURL=graph.photos.js.map