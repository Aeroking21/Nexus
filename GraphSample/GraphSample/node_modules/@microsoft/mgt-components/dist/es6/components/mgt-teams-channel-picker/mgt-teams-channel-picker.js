/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MgtTeamsChannelPicker_1;
import { customElement, html, property } from 'lit-element';
import { classMap } from 'lit-html/directives/class-map';
import { Providers, ProviderState, MgtTemplatedComponent } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import '../sub-components/mgt-spinner/mgt-spinner';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import { debounce } from '../../utils/Utils';
import { styles } from './mgt-teams-channel-picker-css';
import { getAllMyTeams } from './mgt-teams-channel-picker.graph';
import { strings } from './strings';
/**
 * Web component used to select channels from a User's Microsoft Teams profile
 *
 *
 * @class MgtTeamsChannelPicker
 * @extends {MgtTemplatedComponent}
 *
 * @fires selectionChanged - Fired when the selection changes
 *
 * @cssprop --color - {font} Default font color
 *
 * @cssprop --input-border - {String} Input section entire border
 * @cssprop --input-border-top - {String} Input section border top only
 * @cssprop --input-border-right - {String} Input section border right only
 * @cssprop --input-border-bottom - {String} Input section border bottom only
 * @cssprop --input-border-left - {String} Input section border left only
 * @cssprop --input-background-color - {Color} Input section background color
 * @cssprop --input-border-color--hover - {Color} Input border hover color
 * @cssprop --input-border-color--focus - {Color} Input border focus color
 *
 * @cssprop --dropdown-background-color - {Color} Background color of dropdown area
 * @cssprop --dropdown-item-hover-background - {Color} Background color of channel or team during hover
 * @cssprop --dropdown-item-selected-background - {Color} Background color of selected channel
 *
 * @cssprop --arrow-fill - {Color} Color of arrow svg
 * @cssprop --placeholder-color--focus - {Color} Color of placeholder text during focus state
 * @cssprop --placeholder-color - {Color} Color of placeholder text
 *
 */
let MgtTeamsChannelPicker = MgtTeamsChannelPicker_1 = class MgtTeamsChannelPicker extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * user the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    get strings() {
        return strings;
    }
    /**
     * Global Configuration object for all
     * teams channel picker components
     *
     * @static
     * @type {MgtTeamsChannelPickerConfig}
     * @memberof MgtTeamsChannelPicker
     */
    static get config() {
        return this._config;
    }
    /**
     * Gets Selected item to be used
     *
     * @readonly
     * @type {SelectedChannel}
     * @memberof MgtTeamsChannelPicker
     */
    get selectedItem() {
        if (this._selectedItemState) {
            return { channel: this._selectedItemState.item, team: this._selectedItemState.parent.item };
        }
        else {
            return null;
        }
    }
    /**
     * Get the scopes required for teams channel picker
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtTeamsChannelPicker
     */
    static get requiredScopes() {
        if (this.config.useTeamsBasedScopes) {
            return ['team.readbasic.all', 'channel.readbasic.all'];
        }
        else {
            return ['user.read.all', 'group.read.all'];
        }
    }
    set items(value) {
        if (this._items === value) {
            return;
        }
        this._items = value;
        this._treeViewState = value ? this.generateTreeViewState(value) : [];
        this.resetFocusState();
    }
    get items() {
        return this._items;
    }
    // User input in search
    get _input() {
        return this.renderRoot.querySelector('.team-chosen-input');
    }
    constructor() {
        super();
        this._inputValue = '';
        this._isFocused = false;
        this._treeViewState = [];
        // focus state
        this._focusList = [];
        this._focusedIndex = -1;
        this.handleWindowClick = this.handleWindowClick.bind(this);
        this.addEventListener('keydown', e => this.onUserKeyDown(e));
        this.addEventListener('focus', _ => this.loadTeamsIfNotLoaded());
        this.addEventListener('mouseover', _ => this.loadTeamsIfNotLoaded());
    }
    /**
     * Invoked each time the custom element is appended into a document-connected element
     *
     * @memberof MgtTeamsChannelPicker
     */
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('click', this.handleWindowClick);
    }
    /**
     * Invoked each time the custom element is disconnected from the document's DOM
     *
     * @memberof MgtTeamsChannelPicker
     */
    disconnectedCallback() {
        window.removeEventListener('click', this.handleWindowClick);
        super.disconnectedCallback();
    }
    /**
     * selects a channel by looking up the id in the Graph
     *
     * @param {string} channelId MicrosoftGraph.Channel.id
     * @returns {Promise<return>} A promise that will resolve to true if channel was selected
     * @memberof MgtTeamsChannelPicker
     */
    selectChannelById(channelId) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (provider && provider.state === ProviderState.SignedIn) {
                // since the component normally handles loading on hover, forces the load for items
                if (!this.items) {
                    yield this.requestStateUpdate();
                }
                for (const item of this._treeViewState) {
                    for (const channel of item.channels) {
                        if (channel.item.id === channelId) {
                            this.selectChannel(channel);
                            return true;
                        }
                    }
                }
            }
            return false;
        });
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
     * Setting properties inside this method will not trigger the element to update.
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    render() {
        const inputClasses = {
            focused: this._isFocused,
            'input-wrapper': true
        };
        const iconClasses = {
            focused: this._isFocused && !!this._selectedItemState,
            'search-icon': true
        };
        const dropdownClasses = {
            dropdown: true,
            visible: this._isDropdownVisible
        };
        const searchClasses = {
            'hide-icon': !!this._selectedItemState,
            'search-wrapper': true
        };
        return (this.renderTemplate('default', { teams: this.items }) ||
            html `
        <div class="root" @blur=${this.lostFocus} dir=${this.direction}>
          <div class=${classMap(inputClasses)} @click=${this.gainedFocus}>
            ${this.renderSelected()}
            <div class=${classMap(searchClasses)}>${this.renderSearchIcon()} ${this.renderInput()}</div>
          </div>
          ${this.renderCloseButton()}
          <div class=${classMap(dropdownClasses)}>${this.renderDropdown()}</div>
        </div>
      `);
    }
    /**
     * Renders selected channel
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderSelected() {
        if (!this._selectedItemState) {
            return html ``;
        }
        return html `
      <li class="selected-team" title=${this._selectedItemState.item.displayName}>
        <div class="selected-team-name">${this._selectedItemState.parent.item.displayName}</div>
        <div class="arrow">${getSvg(SvgIcon.TeamSeparator, '#B3B0AD')}</div>
        ${this._selectedItemState.item.displayName}
        <div class="search-wrapper">${this.renderSearchIcon()} ${this.renderInput()}</div>
      </li>
    `;
    }
    /**
     * Clears the state of the component
     *
     * @protected
     * @memberof MgtTeamsChannelPicker
     */
    clearState() {
        this._items = [];
        this._inputValue = '';
        this._treeViewState = [];
        this._focusList = [];
    }
    /**
     * Renders search icon
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderSearchIcon() {
        return html `
      <div class="search-icon">
        ${getSvg(SvgIcon.Search, '#252424')}
      </div>
    `;
    }
    /**
     * Renders input field
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderInput() {
        const rootClasses = {
            'input-search': !!this._selectedItemState,
            'input-search-start': !this._selectedItemState
        };
        return html `
      <div class="${classMap(rootClasses)}">
        <span
          id="teams-channel-picker-input"
          class="team-chosen-input"
          type="text"
          label="teams-channel-picker-input"
          aria-label="Select a channel"
          data-placeholder="${!!this._selectedItemState ? '' : this.strings.inputPlaceholderText} "
          role="searchbox"
          @keyup=${e => this.handleInputChanged(e)}
          contenteditable
        ></span>
      </div>
    `;
    }
    /**
     * Renders close button
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderCloseButton() {
        return html `
      <div tabindex="0" class="close-icon"
        @keydown="${() => this.selectChannel(null)}"
        @click="${() => this.selectChannel(null)}"> 
      </div>
    `;
    }
    /**
     * Renders dropdown content
     *
     * @param {ChannelPickerItemState[]} items
     * @param {number} [level=0]
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderDropdown() {
        if (this.isLoadingState || !this._treeViewState) {
            return this.renderLoading();
        }
        if (this._treeViewState) {
            if (!this.isLoadingState && this._treeViewState.length === 0 && this._inputValue.length > 0) {
                return this.renderError();
            }
            return this.renderDropdownList(this._treeViewState);
        }
        return html ``;
    }
    /**
     * Renders the dropdown list recursively
     *
     * @protected
     * @param {ChannelPickerItemState[]} items
     * @param {number} [level=0]
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderDropdownList(items, level = 0) {
        if (items && items.length) {
            return items.map((treeItem, index) => {
                const isLeaf = !treeItem.channels;
                const renderChannels = !isLeaf && treeItem.isExpanded;
                return html `
          ${this.renderItem(treeItem)}
          ${renderChannels ? this.renderDropdownList(treeItem.channels, level + 1) : html ``}
        `;
            });
        }
        return null;
    }
    /**
     * Renders each Channel or Team
     *
     * @param {ChannelPickerItemState} itemState
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderItem(itemState) {
        let icon = null;
        if (itemState.channels) {
            // must be team with channels
            icon = itemState.isExpanded ? getSvg(SvgIcon.ArrowDown, '#252424') : getSvg(SvgIcon.ArrowRight, '#252424');
        }
        let isSelected = false;
        if (this.selectedItem) {
            if (this.selectedItem.channel === itemState.item) {
                isSelected = true;
            }
        }
        const classes = {
            focused: this._focusList[this._focusedIndex] === itemState,
            item: true,
            'list-team': itemState.channels ? true : false,
            selected: isSelected
        };
        const dropDown = this.renderRoot.querySelector('.dropdown');
        if (dropDown.children[this._focusedIndex]) {
            dropDown.children[this._focusedIndex].scrollIntoView(false);
        }
        return html `
      <div @click=${() => this.handleItemClick(itemState)} class="${classMap(classes)}">
        <div class="arrow">
          ${icon}
        </div>
        ${itemState.channels ? itemState.item.displayName : this.renderHighlightedText(itemState.item)}
      </div>
    `;
    }
    /**
     * Renders the channel with the query text higlighted
     *
     * @protected
     * @param {*} channel
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderHighlightedText(channel) {
        // tslint:disable-next-line: prefer-const
        let channels = {};
        const highlightLocation = channel.displayName.toLowerCase().indexOf(this._inputValue.toLowerCase());
        if (highlightLocation !== -1) {
            // no location
            if (highlightLocation === 0) {
                // highlight is at the beginning of sentence
                channels.first = '';
                channels.highlight = channel.displayName.slice(0, this._inputValue.length);
                channels.last = channel.displayName.slice(this._inputValue.length, channel.displayName.length);
            }
            else if (highlightLocation === channel.displayName.length) {
                // highlight is at end of the sentence
                channels.first = channel.displayName.slice(0, highlightLocation);
                channels.highlight = channel.displayName.slice(highlightLocation, channel.displayName.length);
                channels.last = '';
            }
            else {
                // highlight is in middle of sentence
                channels.first = channel.displayName.slice(0, highlightLocation);
                channels.highlight = channel.displayName.slice(highlightLocation, highlightLocation + this._inputValue.length);
                channels.last = channel.displayName.slice(highlightLocation + this._inputValue.length, channel.displayName.length);
            }
        }
        else {
            channels.last = channel.displayName;
        }
        return html `
      <div class="channel-display">
        <div class="showing">
          <span class="channel-name-text">${channels.first}</span
          ><span class="channel-name-text highlight-search-text">${channels.highlight}</span
          ><span class="channel-name-text">${channels.last}</span>
        </div>
      </div>
    `;
    }
    /**
     * Renders an error message when no channel or teams match the query
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderError() {
        const template = this.renderTemplate('error', null, 'error');
        return (template ||
            html `
        <div class="message-parent">
          <div label="search-error-text" aria-label="We didn't find any matches." class="search-error-text">
            ${this.strings.noResultsFound}
          </div>
        </div>
      `);
    }
    /**
     * Renders loading spinner while channels are fetched from the Graph
     *
     * @protected
     * @returns
     * @memberof MgtTeamsChannelPicker
     */
    renderLoading() {
        const template = this.renderTemplate('loading', null, 'loading');
        return (template ||
            html `
        <div class="message-parent">
          <mgt-spinner></mgt-spinner>
          <div label="loading-text" aria-label="loading" class="loading-text">
            ${this.strings.loadingMessage}
          </div>
        </div>
      `);
    }
    /**
     * Queries Microsoft Graph for Teams & respective channels then sets to items list
     *
     * @protected
     * @memberof MgtTeamsChannelPicker
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            let teams;
            if (provider && provider.state === ProviderState.SignedIn) {
                const graph = provider.graph.forComponent(this);
                // make sure we have the needed scopes
                if (!(yield provider.getAccessTokenForScopes(...MgtTeamsChannelPicker_1.requiredScopes))) {
                    return;
                }
                teams = yield getAllMyTeams(graph);
                teams = teams.filter(t => !t.isArchived);
                const batch = graph.createBatch();
                const scopes = ['team.readbasic.all'];
                for (const team of teams) {
                    batch.get(team.id, `teams/${team.id}/channels`, scopes);
                }
                const responses = yield batch.executeAll();
                for (const team of teams) {
                    const response = responses.get(team.id);
                    if (response && response.content && response.content.value) {
                        team.channels = response.content.value.map(c => {
                            return {
                                item: c
                            };
                        });
                    }
                }
                this.items = teams.map(t => {
                    return {
                        channels: t.channels,
                        item: t
                    };
                });
            }
            this.filterList();
            this.resetFocusState();
        });
    }
    handleItemClick(item) {
        if (item.channels) {
            item.isExpanded = !item.isExpanded;
        }
        else {
            this.selectChannel(item);
        }
        this._focusedIndex = -1;
        this.resetFocusState();
    }
    handleInputChanged(e) {
        if (this._inputValue !== e.target.textContent) {
            this._inputValue = e.target.textContent;
        }
        else {
            return;
        }
        // shows list
        this.gainedFocus();
        if (!this.debouncedSearch) {
            this.debouncedSearch = debounce(() => {
                this.filterList();
            }, 400);
        }
        this.debouncedSearch();
    }
    filterList() {
        if (this.items) {
            this._treeViewState = this.generateTreeViewState(this.items, this._inputValue);
            this._focusedIndex = -1;
            this.resetFocusState();
        }
    }
    generateTreeViewState(tree, filterString = '', parent = null) {
        const treeView = [];
        filterString = filterString.toLowerCase();
        if (tree) {
            for (const state of tree) {
                let stateItem;
                if (filterString.length === 0 || state.item.displayName.toLowerCase().includes(filterString)) {
                    stateItem = { item: state.item, parent };
                    if (state.channels) {
                        stateItem.channels = this.generateTreeViewState(state.channels, '', stateItem);
                        stateItem.isExpanded = filterString.length > 0;
                    }
                }
                else if (state.channels) {
                    const newStateItem = { item: state.item, parent };
                    const channels = this.generateTreeViewState(state.channels, filterString, newStateItem);
                    if (channels.length > 0) {
                        stateItem = newStateItem;
                        stateItem.channels = channels;
                        stateItem.isExpanded = true;
                    }
                }
                if (stateItem) {
                    treeView.push(stateItem);
                }
            }
        }
        return treeView;
    }
    // generates a flat list from a tree to facilitate easier focus
    // navigation
    generateFocusList(items) {
        if (!items || items.length === 0) {
            return [];
        }
        let array = [];
        for (const item of items) {
            array.push(item);
            if (item.channels && item.isExpanded) {
                array = [...array, ...this.generateFocusList(item.channels)];
            }
        }
        return array;
    }
    resetFocusState() {
        this._focusList = this.generateFocusList(this._treeViewState);
        this.requestUpdate();
    }
    loadTeamsIfNotLoaded() {
        if (!this.items && !this.isLoadingState) {
            this.requestStateUpdate();
        }
    }
    handleWindowClick(e) {
        if (e.target !== this) {
            this.lostFocus();
        }
    }
    onUserKeyDown(event) {
        if (event.keyCode === 13) {
            // No new line
            event.preventDefault();
        }
        if (this._treeViewState.length === 0) {
            return;
        }
        const currentFocusedItem = this._focusList[this._focusedIndex];
        switch (event.keyCode) {
            case 40: // down
                this._focusedIndex = (this._focusedIndex + 1) % this._focusList.length;
                this.requestUpdate();
                event.preventDefault();
                break;
            case 38: // up
                if (this._focusedIndex === -1) {
                    this._focusedIndex = this._focusList.length;
                }
                this._focusedIndex = (this._focusedIndex - 1 + this._focusList.length) % this._focusList.length;
                this.requestUpdate();
                event.preventDefault();
                break;
            case 39: // right
                if (currentFocusedItem && currentFocusedItem.channels && !currentFocusedItem.isExpanded) {
                    currentFocusedItem.isExpanded = true;
                    this.resetFocusState();
                    event.preventDefault();
                }
                break;
            case 37: // left
                if (currentFocusedItem && currentFocusedItem.channels && currentFocusedItem.isExpanded) {
                    currentFocusedItem.isExpanded = false;
                    this.resetFocusState();
                    event.preventDefault();
                }
                break;
            case 9: // tab
                if (!currentFocusedItem) {
                    this.lostFocus();
                    break;
                }
            case 13: // return/enter
                if (currentFocusedItem && currentFocusedItem.channels) {
                    // focus item is a Team
                    currentFocusedItem.isExpanded = !currentFocusedItem.isExpanded;
                    this.resetFocusState();
                    event.preventDefault();
                }
                else if (currentFocusedItem && !currentFocusedItem.channels) {
                    this.selectChannel(currentFocusedItem);
                    // refocus to new textbox on initial selection
                    this.resetFocusState();
                    this._focusedIndex = -1;
                    event.preventDefault();
                }
                break;
            case 8: // backspace
                if (this._inputValue.length === 0 && this._selectedItemState) {
                    this.selectChannel(null);
                    event.preventDefault();
                }
                break;
            case 27: // esc
                this.selectChannel(this._selectedItemState);
                this._focusedIndex = -1;
                this.resetFocusState();
                event.preventDefault();
                break;
        }
    }
    gainedFocus() {
        this._isFocused = true;
        const input = this._input;
        if (input) {
            input.focus();
        }
        this._isDropdownVisible = true;
    }
    lostFocus() {
        this._isFocused = false;
        const input = this._input;
        if (input) {
            input.textContent = this._inputValue = '';
        }
        this._isDropdownVisible = false;
        this.filterList();
    }
    selectChannel(item) {
        if (this._selectedItemState !== item) {
            this._selectedItemState = item;
            this.fireCustomEvent('selectionChanged', item ? [this.selectedItem] : []);
        }
        const input = this._input;
        if (input) {
            input.textContent = this._inputValue = '';
        }
        this.requestUpdate();
        this.lostFocus();
    }
};
MgtTeamsChannelPicker._config = {
    useTeamsBasedScopes: false
};
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Object)
], MgtTeamsChannelPicker.prototype, "_isDropdownVisible", void 0);
MgtTeamsChannelPicker = MgtTeamsChannelPicker_1 = __decorate([
    customElement('mgt-teams-channel-picker'),
    __metadata("design:paramtypes", [])
], MgtTeamsChannelPicker);
export { MgtTeamsChannelPicker };
//# sourceMappingURL=mgt-teams-channel-picker.js.map