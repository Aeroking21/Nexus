/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes } from '@microsoft/mgt-element';
/**
 * async promise, allows developer to add new to-do task
 *
 * @param {*} newTask
 * @returns {Promise<OutlookTask>}
 * @memberof BetaGraph
 */
export function addTodoTask(graph, newTask) {
    return __awaiter(this, void 0, void 0, function* () {
        const { parentFolderId = null } = newTask;
        if (parentFolderId) {
            return yield graph
                .api(`/me/outlook/taskFolders/${parentFolderId}/tasks`)
                .header('Cache-Control', 'no-store')
                .middlewareOptions(prepScopes('Tasks.ReadWrite'))
                .post(newTask);
        }
        else {
            return yield graph
                .api('/me/outlook/tasks')
                .header('Cache-Control', 'no-store')
                .middlewareOptions(prepScopes('Tasks.ReadWrite'))
                .post(newTask);
        }
    });
}
/**
 * async promise, returns all Outlook taskGroups associated with the logged in user
 *
 * @returns {Promise<OutlookTaskGroup[]>}
 * @memberof BetaGraph
 */
export function getAllMyTodoGroups(graph) {
    return __awaiter(this, void 0, void 0, function* () {
        const groups = yield graph
            .api('/me/outlook/taskGroups')
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Tasks.Read'))
            .get();
        return groups && groups.value;
    });
}
/**
 * async promise, returns all Outlook tasks associated with a taskFolder with folderId
 *
 * @param {string} folderId
 * @returns {Promise<OutlookTask[]>}
 * @memberof BetaGraph
 */
export function getAllTodoTasksForFolder(graph, folderId) {
    return __awaiter(this, void 0, void 0, function* () {
        const tasks = yield graph
            .api(`/me/outlook/taskFolders/${folderId}/tasks`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Tasks.Read'))
            .get();
        return tasks && tasks.value;
    });
}
/**
 * async promise, returns all Outlook taskFolders associated with groupId
 *
 * @param {string} groupId
 * @returns {Promise<OutlookTaskFolder[]>}
 * @memberof BetaGraph
 */
export function getFoldersForTodoGroup(graph, groupId) {
    return __awaiter(this, void 0, void 0, function* () {
        const folders = yield graph
            .api(`/me/outlook/taskGroups/${groupId}/taskFolders`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Tasks.Read'))
            .get();
        return folders && folders.value;
    });
}
/**
 * async promise, returns to-do tasks from Outlook groups associated with a groupId
 *
 * @param {string} groupId
 * @returns {Promise<OutlookTaskGroup>}
 * @memberof BetaGraph
 */
export function getSingleTodoGroup(graph, groupId) {
    return __awaiter(this, void 0, void 0, function* () {
        const group = yield graph
            .api(`/me/outlook/taskGroups/${groupId}`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Tasks.Read'))
            .get();
        return group;
    });
}
/**
 * async promise, allows developer to remove task based on taskId
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof BetaGraph
 */
export function removeTodoTask(graph, taskId, eTag) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield graph
            .api(`/me/outlook/tasks/${taskId}`)
            .header('Cache-Control', 'no-store')
            .header('If-Match', eTag)
            .middlewareOptions(prepScopes('Tasks.ReadWrite'))
            .delete();
    });
}
/**
 * async promise, allows developer to set to-do task to completed state
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<OutlookTask>}
 * @memberof BetaGraph
 */
export function setTodoTaskComplete(graph, taskId, eTag) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield setTodoTaskDetails(graph, taskId, {
            isReminderOn: false,
            status: 'completed'
        }, eTag);
    });
}
/**
 * async promise, allows developer to set to-do task to incomplete state
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<OutlookTask>}
 * @memberof BetaGraph
 */
export function setTodoTaskIncomplete(graph, taskId, eTag) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield setTodoTaskDetails(graph, taskId, {
            isReminderOn: true,
            status: 'notStarted'
        }, eTag);
    });
}
/**
 * async promise, allows developer to redefine to-do Task details associated with a taskId
 *
 * @param {string} taskId
 * @param {*} task
 * @param {string} eTag
 * @returns {Promise<OutlookTask>}
 * @memberof BetaGraph
 */
export function setTodoTaskDetails(graph, taskId, task, eTag) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield graph
            .api(`/me/outlook/tasks/${taskId}`)
            .header('Cache-Control', 'no-store')
            .header('If-Match', eTag)
            .middlewareOptions(prepScopes('Tasks.ReadWrite'))
            .patch(task);
    });
}
//# sourceMappingURL=mgt-tasks.graph.todo.js.map