/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { customElement, html, property } from 'lit-element';
import { CacheService, equals, MgtTemplatedComponent, prepScopes, Providers, ProviderState } from '@microsoft/mgt-element';
import { getPhotoForResource } from '../../graph/graph.photos';
import { getDocumentThumbnail } from '../../graph/graph.files';
import { schemas } from '../../graph/cacheStores';
/**
 * Enumeration to define what types of query are available
 *
 * @export
 * @enum {string}
 */
export var ResponseType;
(function (ResponseType) {
    /**
     * Fetches a call as JSON
     */
    ResponseType["json"] = "json";
    /**
     * Fetches a call as image
     */
    ResponseType["image"] = "image";
})(ResponseType || (ResponseType = {}));
/**
 * Defines the expiration time
 */
const getResponseInvalidationTime = (currentInvalidationPeriod) => currentInvalidationPeriod ||
    CacheService.config.response.invalidationPeriod ||
    CacheService.config.defaultInvalidationPeriod;
/**
 * Whether the response store is enabled
 */
const getIsResponseCacheEnabled = () => CacheService.config.response.isEnabled && CacheService.config.isEnabled;
/**
 * Custom element for making Microsoft Graph get queries
 *
 * @fires dataChange - Fired when data changes
 *
 * @export
 * @class mgt-get
 * @extends {MgtTemplatedComponent}
 */
let MgtGet = class MgtGet extends MgtTemplatedComponent {
    constructor() {
        super(...arguments);
        /**
         * The scopes to request
         *
         * @type {string[]}
         * @memberof MgtGet
         */
        this.scopes = [];
        /**
         * Api version to use for request
         *
         * @type {string}
         * @memberof MgtGet
         */
        this.version = 'v1.0';
        /**
         * Type of response
         * Default = json
         * Supported values = json, image
         *
         * @type {ResponseType}
         * @memberof MgtGet
         */
        this.type = ResponseType.json;
        /**
         * Maximum number of pages to get for the resource
         * default = 3
         * if <= 0, all pages will be fetched
         *
         * @type {number}
         * @memberof MgtGet
         */
        this.maxPages = 3;
        /**
         * Number of milliseconds to poll the delta API and
         * update the response. Set to positive value to enable
         *
         * @type {number}
         * @memberof MgtGet
         */
        this.pollingRate = 0;
        /**
         * Enables cache on the response from the specified resource
         * default = false
         *
         * @type {boolean}
         * @memberof MgtGet
         */
        this.cacheEnabled = false;
        /**
         * Invalidation period of the cache for the responses in milliseconds
         *
         * @type {number}
         * @memberof MgtGet
         */
        this.cacheInvalidationPeriod = 0;
        this.isPolling = false;
        this.isRefreshing = false;
    }
    /**
     * Synchronizes property values when attributes change.
     *
     * @param {*} name
     * @param {*} oldValue
     * @param {*} newValue
     * @memberof MgtPersonCard
     */
    attributeChangedCallback(name, oldval, newval) {
        super.attributeChangedCallback(name, oldval, newval);
        this.requestStateUpdate();
    }
    /**
     * Refresh the data
     *
     * @param {boolean} [hardRefresh=false]
     * if false (default), the component will only update if the data changed
     * if true, the data will be first cleared and reloaded completely
     * @memberof MgtGet
     */
    refresh(hardRefresh = false) {
        this.isRefreshing = true;
        if (hardRefresh) {
            this.clearState();
        }
        this.requestStateUpdate(hardRefresh);
    }
    /**
     * Clears state of the component
     *
     * @protected
     * @memberof MgtGet
     */
    clearState() {
        this.response = null;
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
        if (this.isLoadingState && !this.response) {
            return this.renderTemplate('loading', null);
        }
        else if (this.error) {
            return this.renderTemplate('error', this.error);
            // tslint:disable-next-line: no-string-literal
        }
        else if (this.hasTemplate('value') && this.response && this.response.value) {
            let valueContent;
            if (Array.isArray(this.response.value)) {
                let loading = null;
                if (this.isLoadingState && !this.isPolling) {
                    loading = this.renderTemplate('loading', null);
                }
                valueContent = html `
          ${this.response.value.map(v => this.renderTemplate('value', v, v.id))} ${loading}
        `;
            }
            else {
                valueContent = this.renderTemplate('value', this.response);
            }
            // tslint:disable-next-line: no-string-literal
            if (this.hasTemplate('default')) {
                const defaultContent = this.renderTemplate('default', this.response);
                // tslint:disable-next-line: no-string-literal
                if (this.templates['value'].templateOrder > this.templates['default'].templateOrder) {
                    return html `
            ${defaultContent}${valueContent}
          `;
                }
                else {
                    return html `
            ${valueContent}${defaultContent}
          `;
                }
            }
            else {
                return valueContent;
            }
        }
        else if (this.response) {
            return this.renderTemplate('default', this.response) || html ``;
        }
        else if (this.hasTemplate('no-data')) {
            return this.renderTemplate('no-data', null);
        }
        else {
            return html ``;
        }
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtGet
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            this.error = null;
            if (!provider || provider.state !== ProviderState.SignedIn) {
                return;
            }
            if (this.resource) {
                try {
                    let cache;
                    const key = `${this.version}${this.resource}`;
                    let response = null;
                    if (this.shouldRetrieveCache()) {
                        cache = CacheService.getCache(schemas.get, schemas.get.stores.responses);
                        const result = getIsResponseCacheEnabled() ? yield cache.getValue(key) : null;
                        if (result && getResponseInvalidationTime(this.cacheInvalidationPeriod) > Date.now() - result.timeCached) {
                            response = JSON.parse(result.response);
                        }
                    }
                    if (!response) {
                        let uri = this.resource;
                        let isDeltaLink = false;
                        // if we had a response earlier with a delta link, use it instead
                        if (this.response && this.response['@odata.deltaLink']) {
                            uri = this.response['@odata.deltaLink'];
                            isDeltaLink = true;
                        }
                        else {
                            isDeltaLink = new URL(uri, 'https://graph.microsoft.com').pathname.endsWith('delta');
                        }
                        const graph = provider.graph.forComponent(this);
                        let request = graph.api(uri).version(this.version);
                        if (this.scopes && this.scopes.length) {
                            request = request.middlewareOptions(prepScopes(...this.scopes));
                        }
                        if (this.type === ResponseType.json) {
                            response = yield request.get();
                            if (isDeltaLink && this.response && Array.isArray(this.response.value) && Array.isArray(response.value)) {
                                response.value = this.response.value.concat(response.value);
                            }
                            if (!this.isPolling && !equals(this.response, response)) {
                                this.response = response;
                            }
                            // get more pages if there are available
                            if (response && Array.isArray(response.value) && response['@odata.nextLink']) {
                                let pageCount = 1;
                                let page = response;
                                while ((pageCount < this.maxPages || this.maxPages <= 0 || (isDeltaLink && this.pollingRate)) &&
                                    page &&
                                    page['@odata.nextLink']) {
                                    pageCount++;
                                    const nextResource = page['@odata.nextLink'].split(this.version)[1];
                                    page = yield graph.client.api(nextResource).version(this.version).get();
                                    if (page && page.value && page.value.length) {
                                        page.value = response.value.concat(page.value);
                                        response = page;
                                        if (!this.isPolling) {
                                            this.response = response;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            if (this.resource.indexOf('/photo/$value') === -1 && this.resource.indexOf('/thumbnails/') === -1) {
                                throw new Error('Only /photo/$value and /thumbnails/ endpoints support the image type');
                            }
                            let image;
                            if (this.resource.indexOf('/photo/$value') > -1) {
                                // Sanitizing the resource to ensure getPhotoForResource gets the right format
                                const sanitizedResource = this.resource.replace('/photo/$value', '');
                                const photoResponse = yield getPhotoForResource(graph, sanitizedResource, this.scopes);
                                if (photoResponse) {
                                    image = photoResponse.photo;
                                }
                            }
                            else if (this.resource.indexOf('/thumbnails/') > -1) {
                                const imageResponse = yield getDocumentThumbnail(graph, this.resource, this.scopes);
                                if (imageResponse) {
                                    image = imageResponse.thumbnail;
                                }
                            }
                            if (image) {
                                response = {
                                    image: image
                                };
                            }
                        }
                        if (this.shouldUpdateCache() && response) {
                            cache = CacheService.getCache(schemas.get, schemas.get.stores.responses);
                            cache.putValue(key, { response: JSON.stringify(response) });
                        }
                    }
                    if (!equals(this.response, response)) {
                        this.response = response;
                    }
                }
                catch (e) {
                    this.error = e;
                }
                if (this.response) {
                    this.error = null;
                    if (this.pollingRate) {
                        setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                            this.isPolling = true;
                            yield this.loadState();
                            this.isPolling = false;
                        }), this.pollingRate);
                    }
                }
            }
            else {
                this.response = null;
            }
            this.isRefreshing = false;
            this.fireCustomEvent('dataChange', { response: this.response, error: this.error });
        });
    }
    shouldRetrieveCache() {
        return getIsResponseCacheEnabled() && this.cacheEnabled && !(this.isRefreshing || this.isPolling);
    }
    shouldUpdateCache() {
        return getIsResponseCacheEnabled() && this.cacheEnabled;
    }
};
__decorate([
    property({
        attribute: 'resource',
        reflect: true,
        type: String
    }),
    __metadata("design:type", String)
], MgtGet.prototype, "resource", void 0);
__decorate([
    property({
        attribute: 'scopes',
        converter: (value, type) => {
            return value ? value.toLowerCase().split(',') : null;
        },
        reflect: true
    }),
    __metadata("design:type", Array)
], MgtGet.prototype, "scopes", void 0);
__decorate([
    property({
        attribute: 'version',
        reflect: true,
        type: String
    }),
    __metadata("design:type", String)
], MgtGet.prototype, "version", void 0);
__decorate([
    property({
        attribute: 'type',
        reflect: true,
        type: ResponseType
    }),
    __metadata("design:type", String)
], MgtGet.prototype, "type", void 0);
__decorate([
    property({
        attribute: 'max-pages',
        reflect: true,
        type: Number
    }),
    __metadata("design:type", Number)
], MgtGet.prototype, "maxPages", void 0);
__decorate([
    property({
        attribute: 'polling-rate',
        reflect: true,
        type: Number
    }),
    __metadata("design:type", Number)
], MgtGet.prototype, "pollingRate", void 0);
__decorate([
    property({
        attribute: 'cache-enabled',
        reflect: true,
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtGet.prototype, "cacheEnabled", void 0);
__decorate([
    property({
        attribute: 'cache-invalidation-period',
        reflect: true,
        type: Number
    }),
    __metadata("design:type", Number)
], MgtGet.prototype, "cacheInvalidationPeriod", void 0);
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Object)
], MgtGet.prototype, "response", void 0);
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Object)
], MgtGet.prototype, "error", void 0);
MgtGet = __decorate([
    customElement('mgt-get')
], MgtGet);
export { MgtGet };
//# sourceMappingURL=mgt-get.js.map