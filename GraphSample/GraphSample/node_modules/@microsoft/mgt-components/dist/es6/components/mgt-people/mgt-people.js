/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { customElement, html, property } from 'lit-element';
import { repeat } from 'lit-html/directives/repeat';
import { getPeople, getPeopleFromResource, PersonType } from '../../graph/graph.people';
import { getUsersPresenceByPeople } from '../../graph/graph.presence';
import { findGroupMembers, getUsersForPeopleQueries, getUsersForUserIds } from '../../graph/graph.user';
import { Providers, ProviderState, MgtTemplatedComponent, arraysAreEqual } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import { PersonCardInteraction } from './../PersonCardInteraction';
import { styles } from './mgt-people-css';
import { MgtPerson } from '../mgt-person/mgt-person';
export { PersonCardInteraction } from './../PersonCardInteraction';
/**
 * web component to display a group of people or contacts by using their photos or initials.
 *
 * @export
 * @class MgtPeople
 * @extends {MgtTemplatedComponent}
 *
 * @cssprop --list-margin - {String} List margin for component
 * @cssprop --avatar-margin - {String} Margin for each person
 */
let MgtPeople = class MgtPeople extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * determines if agenda events come from specific group
     * @type {string}
     */
    get groupId() {
        return this._groupId;
    }
    set groupId(value) {
        if (this._groupId === value) {
            return;
        }
        this._groupId = value;
        this.requestStateUpdate(true);
    }
    /**
     * user id array
     *
     * @memberof MgtPeople
     */
    get userIds() {
        return this._userIds;
    }
    set userIds(value) {
        if (arraysAreEqual(this._userIds, value)) {
            return;
        }
        this._userIds = value;
        this.requestStateUpdate(true);
    }
    /**
     * allows developer to define queries of people for component
     * @type {string[]}
     */
    get peopleQueries() {
        return this._peopleQueries;
    }
    set peopleQueries(value) {
        if (arraysAreEqual(this._peopleQueries, value)) {
            return;
        }
        this._peopleQueries = value;
        this.requestStateUpdate(true);
    }
    /**
     * The resource to get
     *
     * @type {string}
     * @memberof MgtPeople
     */
    get resource() {
        return this._resource;
    }
    set resource(value) {
        if (this._resource === value) {
            return;
        }
        this._resource = value;
        this.requestStateUpdate(true);
    }
    /**
     * Api version to use for request
     *
     * @type {string}
     * @memberof MgtPeople
     */
    get version() {
        return this._version;
    }
    set version(value) {
        if (this._version === value) {
            return;
        }
        this._version = value;
        this.requestStateUpdate(true);
    }
    /**
     * Fallback when no user is found
     * @type {IDynamicPerson[]}
     */
    get fallbackDetails() {
        return this._fallbackDetails;
    }
    set fallbackDetails(value) {
        if (value === this._fallbackDetails) {
            return;
        }
        this._fallbackDetails = value;
        this.requestStateUpdate();
    }
    /**
     * Get the scopes required for people
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPeople
     */
    static get requiredScopes() {
        return [
            ...new Set([
                'user.read.all',
                'people.read',
                'user.readbasic.all',
                'presence.read.all',
                'contacts.read',
                ...MgtPerson.requiredScopes
            ])
        ];
    }
    constructor() {
        super();
        /**
         * Sets how the person-card is invoked
         * Set to PersonCardInteraction.none to not show the card
         *
         * @type {PersonCardInteraction}
         * @memberof MgtPerson
         */
        this.personCardInteraction = PersonCardInteraction.hover;
        /**
         * The scopes to request
         *
         * @type {string[]}
         * @memberof MgtPeople
         */
        this.scopes = [];
        this._version = 'v1.0';
        this.showMax = 3;
    }
    /**
     * Clears the state of the component
     *
     * @protected
     * @memberof MgtPeople
     */
    clearState() {
        this.people = null;
    }
    /**
     * Request to reload the state.
     * Use reload instead of load to ensure loading events are fired.
     *
     * @protected
     * @memberof MgtBaseComponent
     */
    requestStateUpdate(force) {
        if (force) {
            this.people = null;
        }
        return super.requestStateUpdate(force);
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
        if (this.isLoadingState) {
            return this.renderLoading();
        }
        if (!this.people || this.people.length === 0) {
            return this.renderNoData();
        }
        return this.renderTemplate('default', { people: this.people, max: this.showMax }) || this.renderPeople();
    }
    /**
     * Render the loading state.
     *
     * @protected
     * @returns
     * @memberof MgtPeople
     */
    renderLoading() {
        return this.renderTemplate('loading', null) || html ``;
    }
    /**
     * Render the list of people.
     *
     * @protected
     * @param {*} people
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderPeople() {
        const maxPeople = this.people.slice(0, this.showMax).filter(pple => pple);
        return html `
      <ul class="people-list" aria-label="people">
        ${repeat(maxPeople, p => (p.id ? p.id : p.displayName), p => html `
            <li class="people-person">
              ${this.renderPerson(p)}
            </li>
          `)}
        ${this.people.length > this.showMax ? this.renderOverflow() : null}
      </ul>
    `;
    }
    /**
     * Render the overflow content to represent any extra people, beyond the max.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderOverflow() {
        const extra = this.people.length - this.showMax;
        return (this.renderTemplate('overflow', {
            extra,
            max: this.showMax,
            people: this.people
        }) ||
            html `
        <li aria-label="and ${extra} more attendees" class="overflow"><span>+${extra}<span></li>
      `);
    }
    /**
     * Render an individual person.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderPerson(person) {
        let personPresence = {
            // set up default presence
            activity: 'Offline',
            availability: 'Offline',
            id: null
        };
        if (this.showPresence && this._peoplePresence) {
            personPresence = this._peoplePresence[person.id];
        }
        const avatarSize = 'small';
        return (this.renderTemplate('person', { person }, person.id) ||
            // set image to @ to flag the mgt-person component to
            // query the image from the graph
            html `
        <mgt-person
          .personDetails=${person}
          .fetchImage=${true}
          .avatarSize=${avatarSize}
          .personCardInteraction=${this.personCardInteraction}
          .showPresence=${this.showPresence}
          .personPresence=${personPresence}
        ></mgt-person>
      `);
    }
    /**
     * render the no data state.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeople
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtPeople
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.people) {
                const provider = Providers.globalProvider;
                if (provider && provider.state === ProviderState.SignedIn) {
                    const graph = provider.graph.forComponent(this);
                    // populate people
                    if (this.groupId) {
                        this.people = yield findGroupMembers(graph, null, this.groupId, this.showMax, PersonType.person);
                    }
                    else if (this.userIds || this.peopleQueries) {
                        this.userIds
                            ? (this.people = yield getUsersForUserIds(graph, this.userIds))
                            : (this.people = yield getUsersForPeopleQueries(graph, this.peopleQueries));
                        if (this._fallbackDetails) {
                            // replace null people with fallback details
                            this.people = this.people.map((p, i) => {
                                if (p) {
                                    return p;
                                }
                                else if (i < this._fallbackDetails.length) {
                                    return this._fallbackDetails[i];
                                }
                                return null;
                            });
                        }
                        else {
                            // remove null people from the array
                            this.people = this.people.filter(p => p !== null);
                        }
                    }
                    else if (this.resource) {
                        this.people = yield getPeopleFromResource(graph, this.version, this.resource, this.scopes);
                    }
                    else {
                        this.people = yield getPeople(graph);
                    }
                    // populate presence for people
                    if (this.showPresence) {
                        this._peoplePresence = yield getUsersPresenceByPeople(graph, this.people);
                    }
                    else {
                        this._peoplePresence = null;
                    }
                }
            }
        });
    }
};
__decorate([
    property({
        attribute: 'group-id',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtPeople.prototype, "groupId", null);
__decorate([
    property({
        attribute: 'user-ids',
        converter: (value, type) => {
            return value.split(',').map(v => v.trim());
        }
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeople.prototype, "userIds", null);
__decorate([
    property({
        attribute: 'people',
        type: Object
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "people", void 0);
__decorate([
    property({
        attribute: 'people-queries',
        converter: (value, type) => {
            return value.split(',').map(v => v.trim());
        }
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeople.prototype, "peopleQueries", null);
__decorate([
    property({
        attribute: 'show-max',
        type: Number
    }),
    __metadata("design:type", Number)
], MgtPeople.prototype, "showMax", void 0);
__decorate([
    property({
        attribute: 'show-presence',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPeople.prototype, "showPresence", void 0);
__decorate([
    property({
        attribute: 'person-card',
        converter: (value, type) => {
            value = value.toLowerCase();
            if (typeof PersonCardInteraction[value] === 'undefined') {
                return PersonCardInteraction.hover;
            }
            else {
                return PersonCardInteraction[value];
            }
        }
    }),
    __metadata("design:type", Number)
], MgtPeople.prototype, "personCardInteraction", void 0);
__decorate([
    property({
        attribute: 'resource',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtPeople.prototype, "resource", null);
__decorate([
    property({
        attribute: 'version',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtPeople.prototype, "version", null);
__decorate([
    property({
        attribute: 'scopes',
        converter: value => {
            return value ? value.toLowerCase().split(',') : null;
        },
        reflect: true
    }),
    __metadata("design:type", Array)
], MgtPeople.prototype, "scopes", void 0);
__decorate([
    property({
        attribute: 'fallback-details',
        type: Array
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeople.prototype, "fallbackDetails", null);
MgtPeople = __decorate([
    customElement('mgt-people'),
    __metadata("design:paramtypes", [])
], MgtPeople);
export { MgtPeople };
//# sourceMappingURL=mgt-people.js.map