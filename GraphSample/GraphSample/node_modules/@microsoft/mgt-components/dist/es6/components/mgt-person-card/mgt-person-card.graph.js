/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { getEmailFromGraphEntity } from '../../graph/graph.people';
// tslint:disable-next-line:completed-docs
const userProperties = 'businessPhones,companyName,department,displayName,givenName,jobTitle,mail,mobilePhone,officeLocation,preferredLanguage,surname,userPrincipalName,id,accountEnabled';
// tslint:disable-next-line:completed-docs
const batchKeys = {
    directReports: 'directReports',
    files: 'files',
    messages: 'messages',
    people: 'people',
    person: 'person'
};
/**
 * Get data to populate the person card
 *
 * @export
 * @param {IGraph} graph
 * @param {IDynamicPerson} personDetails
 * @param {boolean} isMe
 * @param {MgtPersonCardConfig} config
 * @return {*}  {Promise<MgtPersonCardState>}
 */
export function getPersonCardGraphData(graph, personDetails, isMe, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const userId = personDetails.id;
        const email = getEmailFromGraphEntity(personDetails);
        const isContactOrGroup = 'classification' in personDetails ||
            ('personType' in personDetails &&
                (personDetails.personType.subclass === 'PersonalContact' || personDetails.personType.class === 'Group'));
        const batch = graph.createBatch();
        if (!isContactOrGroup) {
            if (config.sections.organization) {
                buildOrgStructureRequest(batch, userId);
                if (typeof config.sections.organization !== 'boolean' && config.sections.organization.showWorksWith) {
                    buildWorksWithRequest(batch, userId);
                }
            }
        }
        if (config.sections.mailMessages && email) {
            buildMessagesWithUserRequest(batch, email);
        }
        if (config.sections.files) {
            buildFilesRequest(batch, isMe ? null : email);
        }
        let response;
        const data = {}; // TODO
        try {
            response = yield batch.executeAll();
        }
        catch (_a) {
            // nop
        }
        if (response) {
            for (const [key, value] of response) {
                data[key] = value.content.value || value.content;
            }
        }
        if (!isContactOrGroup && config.sections.profile) {
            try {
                const profile = yield getProfile(graph, userId);
                if (profile) {
                    data.profile = profile;
                }
            }
            catch (_b) {
                // nop
            }
        }
        // filter out disabled users from direct reports.
        if (data.directReports && data.directReports.length > 0) {
            data.directReports = data.directReports.filter(report => report.accountEnabled);
        }
        return data;
    });
}
// tslint:disable-next-line:completed-docs
function buildOrgStructureRequest(batch, userId) {
    const expandManagers = `manager($levels=max;$select=${userProperties})`;
    batch.get(batchKeys.person, `users/${userId}?$expand=${expandManagers}&$select=${userProperties}&$count=true`, ['user.read.all'], {
        ConsistencyLevel: 'eventual'
    });
    batch.get(batchKeys.directReports, `users/${userId}/directReports?$select=${userProperties}`);
}
// tslint:disable-next-line:completed-docs
function buildWorksWithRequest(batch, userId) {
    batch.get(batchKeys.people, `users/${userId}/people?$filter=personType/class eq 'Person'`, ['People.Read.All']);
}
// tslint:disable-next-line:completed-docs
function buildMessagesWithUserRequest(batch, emailAddress) {
    batch.get(batchKeys.messages, `me/messages?$search="from:${emailAddress}"`, ['Mail.ReadBasic']);
}
// tslint:disable-next-line:completed-docs
function buildFilesRequest(batch, emailAddress) {
    let request;
    if (emailAddress) {
        request = `me/insights/shared?$filter=lastshared/sharedby/address eq '${emailAddress}'`;
    }
    else {
        request = 'me/insights/used';
    }
    batch.get(batchKeys.files, request, ['Sites.Read.All']);
}
/**
 * Get the profile for a user
 *
 * @param {IGraph} graph
 * @param {string} userId
 * @return {*}  {Promise<Profile>}
 */
function getProfile(graph, userId) {
    return __awaiter(this, void 0, void 0, function* () {
        const profile = yield graph.api(`/users/${userId}/profile`).version('beta').get();
        return profile;
    });
}
//# sourceMappingURL=mgt-person-card.graph.js.map