/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { customElement, html, property } from 'lit-element';
import { styles } from './mgt-file-css';
import { MgtTemplatedComponent, Providers, ProviderState } from '@microsoft/mgt-element';
import { getDriveItemById, getDriveItemByPath, getDriveItemByQuery, getGroupDriveItemById, getGroupDriveItemByPath, getListDriveItemById, getMyDriveItemById, getMyDriveItemByPath, getMyInsightsDriveItemById, getSiteDriveItemById, getSiteDriveItemByPath, getUserDriveItemById, getUserDriveItemByPath, getUserInsightsDriveItemById } from '../../graph/graph.files';
import { getRelativeDisplayDate } from '../../utils/Utils';
import { ViewType } from '../../graph/types';
import { getFileTypeIconUriByExtension } from '../../styles/fluent-icons';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import { strings } from './strings';
/**
 * The File component is used to represent an individual file/folder from OneDrive or SharePoint by displaying information such as the file/folder name, an icon indicating the file type, and other properties such as the author, last modified date, or other details selected by the developer.
 *
 * @export
 * @class MgtFile
 * @extends {MgtTemplatedComponent}
 *
 * @cssprop --file-type-icon-size - {Length} file type icon size
 * @cssprop --file-border - {String} file item border style
 * @cssprop --file-box-shadow - {String} file item box shadow style
 * @cssprop --file-background-color - {Color} file background color
 * @cssprop --font-family - {String} Font family
 * @cssprop --font-size - {Length} Font size
 * @cssprop --font-weight - {Length} Font weight
 * @cssprop --text-transform - {String} text transform
 * @cssprop --color -{Color} text color
 * @cssprop --line2-font-size - {Length} Line 2 font size
 * @cssprop --line2-font-weight - {Length} Line 2 font weight
 * @cssprop --line2-color - {Color} Line 2 color
 * @cssprop --line2-text-transform - {String} Line 2 text transform
 * @cssprop --line3-font-size - {Length} Line 2 font size
 * @cssprop --line3-font-weight - {Length} Line 2 font weight
 * @cssprop --line3-color - {Color} Line 2 color
 * @cssprop --line3-text-transform - {String} Line 2 text transform
 */
let MgtFile = class MgtFile extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    get strings() {
        return strings;
    }
    /**
     * allows developer to provide query for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get fileQuery() {
        return this._fileQuery;
    }
    set fileQuery(value) {
        if (value === this._fileQuery) {
            return;
        }
        this._fileQuery = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide site id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get siteId() {
        return this._siteId;
    }
    set siteId(value) {
        if (value === this._siteId) {
            return;
        }
        this._siteId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide drive id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get driveId() {
        return this._driveId;
    }
    set driveId(value) {
        if (value === this._driveId) {
            return;
        }
        this._driveId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide group id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get groupId() {
        return this._groupId;
    }
    set groupId(value) {
        if (value === this._groupId) {
            return;
        }
        this._groupId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide list id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get listId() {
        return this._listId;
    }
    set listId(value) {
        if (value === this._listId) {
            return;
        }
        this._listId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide user id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get userId() {
        return this._userId;
    }
    set userId(value) {
        if (value === this._userId) {
            return;
        }
        this._userId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide item id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get itemId() {
        return this._itemId;
    }
    set itemId(value) {
        if (value === this._itemId) {
            return;
        }
        this._itemId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide item path for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get itemPath() {
        return this._itemPath;
    }
    set itemPath(value) {
        if (value === this._itemPath) {
            return;
        }
        this._itemPath = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide insight type for a file
     * can be trending, used, or shared
     *
     * @type {OfficeGraphInsightString}
     * @memberof MgtFile
     */
    get insightType() {
        return this._insightType;
    }
    set insightType(value) {
        if (value === this._insightType) {
            return;
        }
        this._insightType = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide insight id for a file
     *
     * @type {string}
     * @memberof MgtFile
     */
    get insightId() {
        return this._insightId;
    }
    set insightId(value) {
        if (value === this._insightId) {
            return;
        }
        this._insightId = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide DriveItem object
     *
     * @type {MicrosoftGraph.DriveItem}
     * @memberof MgtFile
     */
    get fileDetails() {
        return this._fileDetails;
    }
    set fileDetails(value) {
        if (value === this._fileDetails) {
            return;
        }
        this._fileDetails = value;
        this.requestStateUpdate();
    }
    /**
     * allows developer to provide file type icon url
     *
     * @type {string}
     * @memberof MgtFile
     */
    get fileIcon() {
        return this._fileIcon;
    }
    set fileIcon(value) {
        if (value === this._fileIcon) {
            return;
        }
        this._fileIcon = value;
        this.requestStateUpdate();
    }
    /**
     * Get the scopes required for file
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtFile
     */
    static get requiredScopes() {
        return [...new Set(['files.read', 'files.read.all', 'sites.read.all'])];
    }
    constructor() {
        super();
        this.line1Property = 'name';
        this.line2Property = 'lastModifiedDateTime';
        this.line3Property = 'size';
        this.view = ViewType.threelines;
    }
    render() {
        if (!this.driveItem && this.isLoadingState) {
            return this.renderLoading();
        }
        if (!this.driveItem) {
            return this.renderNoData();
        }
        const file = this.driveItem;
        let fileTemplate;
        fileTemplate = this.renderTemplate('default', { file });
        if (!fileTemplate) {
            const fileDetailsTemplate = this.renderDetails(file);
            const fileTypeIconTemplate = this.renderFileTypeIcon();
            fileTemplate = html `
        <div class="item">
          ${fileTypeIconTemplate} ${fileDetailsTemplate}
        </div>
      `;
        }
        return html `
      <span dir=${this.direction}>
        ${fileTemplate}
      </span>
    `;
    }
    /**
     * Render the loading state
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtFile
     */
    renderLoading() {
        return this.renderTemplate('loading', null) || html ``;
    }
    /**
     * Render the state when no data is available
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtFile
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * Render the file type icon
     *
     * @protected
     * @param {string} [iconSrc]
     * @memberof MgtFile
     */
    renderFileTypeIcon() {
        if (!this.fileIcon && !this.driveItem.name) {
            return html ``;
        }
        let fileIconSrc;
        if (this.fileIcon) {
            fileIconSrc = this.fileIcon;
        }
        else {
            // get file type extension from file name
            const re = /(?:\.([^.]+))?$/;
            const fileType = this.driveItem.package === undefined && this.driveItem.folder === undefined
                ? re.exec(this.driveItem.name)[1]
                    ? re.exec(this.driveItem.name)[1].toLowerCase()
                    : 'null'
                : this.driveItem.package !== undefined
                    ? this.driveItem.package.type === 'oneNote'
                        ? 'onetoc'
                        : 'folder'
                    : 'folder';
            fileIconSrc = getFileTypeIconUriByExtension(fileType, 48, 'svg');
        }
        return html `
      <div class="item__file-type-icon">
        ${fileIconSrc
            ? html `
              <img src=${fileIconSrc} alt="File icon" />
            `
            : html `
              ${getSvg(SvgIcon.File)}
            `}
      </div>
    `;
    }
    /**
     * Render the file details
     *
     * @protected
     * @param {MicrosoftGraph.DriveItem} [driveItem]
     * @memberof MgtFile
     */
    renderDetails(driveItem) {
        if (!driveItem || this.view === ViewType.image) {
            return html ``;
        }
        const details = [];
        if (this.view > ViewType.image) {
            const text = this.getTextFromProperty(driveItem, this.line1Property);
            if (text) {
                details.push(html `
          <div class="line1" aria-label="${text}">${text}</div>
        `);
            }
        }
        if (this.view > ViewType.oneline) {
            const text = this.getTextFromProperty(driveItem, this.line2Property);
            if (text) {
                details.push(html `
          <div class="line2" aria-label="${text}">${text}</div>
        `);
            }
        }
        if (this.view > ViewType.twolines) {
            const text = this.getTextFromProperty(driveItem, this.line3Property);
            if (text) {
                details.push(html `
          <div class="line3" aria-label="${text}">${text}</div>
        `);
            }
        }
        return html `
      <div class="item__details">
        ${details}
      </div>
    `;
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtFile
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fileDetails) {
                this.driveItem = this.fileDetails;
                return;
            }
            const provider = Providers.globalProvider;
            if (!provider || provider.state === ProviderState.Loading) {
                return;
            }
            if (provider.state === ProviderState.SignedOut) {
                this.driveItem = null;
                return;
            }
            const graph = provider.graph.forComponent(this);
            let driveItem;
            // evaluate to true when only item-id or item-path is provided
            const getFromMyDrive = !this.driveId && !this.siteId && !this.groupId && !this.listId && !this.userId;
            if (
            // return null when a combination of provided properties are required
            (this.driveId && !this.itemId && !this.itemPath) ||
                (this.siteId && !this.itemId && !this.itemPath) ||
                (this.groupId && !this.itemId && !this.itemPath) ||
                (this.listId && !this.siteId && !this.itemId) ||
                (this.insightType && !this.insightId) ||
                (this.userId && !this.itemId && !this.itemPath && !this.insightType && !this.insightId)) {
                driveItem = null;
            }
            else if (this.fileQuery) {
                driveItem = yield getDriveItemByQuery(graph, this.fileQuery);
            }
            else if (this.itemId && getFromMyDrive) {
                driveItem = yield getMyDriveItemById(graph, this.itemId);
            }
            else if (this.itemPath && getFromMyDrive) {
                driveItem = yield getMyDriveItemByPath(graph, this.itemPath);
            }
            else if (this.userId) {
                if (this.itemId) {
                    driveItem = yield getUserDriveItemById(graph, this.userId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getUserDriveItemByPath(graph, this.userId, this.itemPath);
                }
                else if (this.insightType && this.insightId) {
                    driveItem = yield getUserInsightsDriveItemById(graph, this.userId, this.insightType, this.insightId);
                }
            }
            else if (this.driveId) {
                if (this.itemId) {
                    driveItem = yield getDriveItemById(graph, this.driveId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getDriveItemByPath(graph, this.driveId, this.itemPath);
                }
            }
            else if (this.siteId && !this.listId) {
                if (this.itemId) {
                    driveItem = yield getSiteDriveItemById(graph, this.siteId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getSiteDriveItemByPath(graph, this.siteId, this.itemPath);
                }
            }
            else if (this.listId) {
                driveItem = yield getListDriveItemById(graph, this.siteId, this.listId, this.itemId);
            }
            else if (this.groupId) {
                if (this.itemId) {
                    driveItem = yield getGroupDriveItemById(graph, this.groupId, this.itemId);
                }
                else if (this.itemPath) {
                    driveItem = yield getGroupDriveItemByPath(graph, this.groupId, this.itemPath);
                }
            }
            else if (this.insightType && !this.userId) {
                driveItem = yield getMyInsightsDriveItemById(graph, this.insightType, this.insightId);
            }
            this.driveItem = driveItem;
        });
    }
    getTextFromProperty(driveItem, properties) {
        if (!properties || properties.length === 0) {
            return null;
        }
        const propertyList = properties.trim().split(',');
        let text;
        let i = 0;
        while (!text && i < propertyList.length) {
            const current = propertyList[i].trim();
            switch (current) {
                case 'size':
                    // convert size to kb, mb, gb
                    let size;
                    if (driveItem.size) {
                        size = this.formatBytes(driveItem.size);
                    }
                    else {
                        size = '0';
                    }
                    text = `${this.strings.sizeSubtitle}: ${size}`;
                    break;
                case 'lastModifiedDateTime':
                    // convert date time
                    let relativeDateString;
                    let lastModifiedString;
                    if (driveItem.lastModifiedDateTime) {
                        const lastModifiedDateTime = new Date(driveItem.lastModifiedDateTime);
                        relativeDateString = getRelativeDisplayDate(lastModifiedDateTime);
                        lastModifiedString = `${this.strings.modifiedSubtitle} ${relativeDateString}`;
                    }
                    else {
                        lastModifiedString = '';
                    }
                    text = lastModifiedString;
                    break;
                default:
                    text = driveItem[current];
            }
            i++;
        }
        return text;
    }
    formatBytes(bytes, decimals = 2) {
        if (bytes === 0)
            return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
};
__decorate([
    property({
        attribute: 'file-query'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "fileQuery", null);
__decorate([
    property({
        attribute: 'site-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "siteId", null);
__decorate([
    property({
        attribute: 'drive-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "driveId", null);
__decorate([
    property({
        attribute: 'group-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "groupId", null);
__decorate([
    property({
        attribute: 'list-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "listId", null);
__decorate([
    property({
        attribute: 'user-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "userId", null);
__decorate([
    property({
        attribute: 'item-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "itemId", null);
__decorate([
    property({
        attribute: 'item-path'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "itemPath", null);
__decorate([
    property({
        attribute: 'insight-type'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "insightType", null);
__decorate([
    property({
        attribute: 'insight-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "insightId", null);
__decorate([
    property({
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtFile.prototype, "fileDetails", null);
__decorate([
    property({
        attribute: 'file-icon'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtFile.prototype, "fileIcon", null);
__decorate([
    property({ type: Object }),
    __metadata("design:type", Object)
], MgtFile.prototype, "driveItem", void 0);
__decorate([
    property({ attribute: 'line1-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line1Property", void 0);
__decorate([
    property({ attribute: 'line2-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line2Property", void 0);
__decorate([
    property({ attribute: 'line3-property' }),
    __metadata("design:type", String)
], MgtFile.prototype, "line3Property", void 0);
__decorate([
    property({
        attribute: 'view',
        converter: value => {
            if (!value || value.length === 0) {
                return ViewType.threelines;
            }
            value = value.toLowerCase();
            if (typeof ViewType[value] === 'undefined') {
                return ViewType.threelines;
            }
            else {
                return ViewType[value];
            }
        }
    }),
    __metadata("design:type", Number)
], MgtFile.prototype, "view", void 0);
MgtFile = __decorate([
    customElement('mgt-file'),
    __metadata("design:paramtypes", [])
], MgtFile);
export { MgtFile };
//# sourceMappingURL=mgt-file.js.map