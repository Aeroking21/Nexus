/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { customElement, html, property } from 'lit-element';
import { Providers, ProviderState, MgtTemplatedComponent, prepScopes } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import '../mgt-person/mgt-person';
import { styles } from './mgt-agenda-css';
import { getEventsPageIterator } from './mgt-agenda.graph';
import { SvgIcon, getSvg } from '../../utils/SvgHelper';
import { MgtPeople } from '../mgt-people/mgt-people';
/**
 * Web Component which represents events in a user or group calendar.
 *
 * @export
 * @class MgtAgenda
 * @extends {MgtTemplatedComponent}
 *
 * @fires eventClick - Fired when user click an event
 *
 * @cssprop --event-box-shadow - {String} Event box shadow color and size
 * @cssprop --event-margin - {String} Event margin
 * @cssprop --event-padding - {String} Event padding
 * @cssprop --event-background-color - {Color} Event background color
 * @cssprop --event-border - {String} Event border style
 * @cssprop --agenda-header-margin - {String} Agenda header margin size
 * @cssprop --agenda-header-font-size - {Length} Agenda header font size
 * @cssprop --agenda-header-color - {Color} Agenda header color
 * @cssprop --event-time-font-size - {Length} Event time font size
 * @cssprop --event-time-color - {Color} Event time color
 * @cssprop --event-subject-font-size - {Length} Event subject font size
 * @cssprop --event-subject-color - {Color} Event subject color
 * @cssprop --event-location-font-size - {Length} Event location font size
 * @cssprop --event-location-color - {Color} Event location color
 */
let MgtAgenda = class MgtAgenda extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * stores current date for initial calender selection in events.
     * @type {string}
     */
    get date() {
        return this._date;
    }
    set date(value) {
        if (this._date === value) {
            return;
        }
        this._date = value;
        this.reloadState();
    }
    /**
     * determines if agenda events come from specific group
     * @type {string}
     */
    get groupId() {
        return this._groupId;
    }
    set groupId(value) {
        if (this._groupId === value) {
            return;
        }
        this._groupId = value;
        this.reloadState();
    }
    /**
     * sets number of days until end date, 3 is the default
     * @type {number}
     */
    get days() {
        return this._days;
    }
    set days(value) {
        if (this._days === value) {
            return;
        }
        this._days = value;
        this.reloadState();
    }
    /**
     * allows developer to specify a different graph query that retrieves events
     * @type {string}
     */
    get eventQuery() {
        return this._eventQuery;
    }
    set eventQuery(value) {
        if (this._eventQuery === value) {
            return;
        }
        this._eventQuery = value;
        this.reloadState();
    }
    /**
     * allows developer to specify preferred timezone that should be used for
     * retrieving events from Graph, eg. `Pacific Standard Time`. The preferred timezone for
     * the current user can be retrieved by calling `me/mailboxSettings` and
     * retrieving the value of the `timeZone` property.
     * @type {string}
     */
    get preferredTimezone() {
        return this._preferredTimezone;
    }
    set preferredTimezone(value) {
        if (this._preferredTimezone === value) {
            return;
        }
        this._preferredTimezone = value;
        this.reloadState();
    }
    /**
     * Get the scopes required for agenda
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtAgenda
     */
    static get requiredScopes() {
        return [...new Set(['calendars.read', ...MgtPeople.requiredScopes])];
    }
    constructor() {
        super();
        this._days = 3;
        this.onResize = this.onResize.bind(this);
    }
    /**
     * Determines width available if resize is necessary, adds onResize event listener to window
     *
     * @memberof MgtAgenda
     */
    connectedCallback() {
        this._isNarrow = this.offsetWidth < 600;
        super.connectedCallback();
        window.addEventListener('resize', this.onResize);
    }
    /**
     * Removes onResize event listener from window
     *
     * @memberof MgtAgenda
     */
    disconnectedCallback() {
        window.removeEventListener('resize', this.onResize);
        super.disconnectedCallback();
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
     * Setting properties inside this method will not trigger the element to update
     *
     * @returns
     * @memberof MgtAgenda
     */
    render() {
        // Loading
        if (!this.events && this.isLoadingState) {
            return this.renderLoading();
        }
        // No data
        if (!this.events || this.events.length === 0) {
            return this.renderNoData();
        }
        // Prep data
        const events = this.showMax && this.showMax > 0 ? this.events.slice(0, this.showMax) : this.events;
        // Default template
        const renderedTemplate = this.renderTemplate('default', { events });
        if (renderedTemplate) {
            return renderedTemplate;
        }
        // Update narrow state
        this._isNarrow = this.offsetWidth < 600;
        // Render list
        return html `
      <div dir=${this.direction} class="agenda${this._isNarrow ? ' narrow' : ''}${this.groupByDay ? ' grouped' : ''}">
        ${this.groupByDay ? this.renderGroups(events) : this.renderEvents(events)}
        ${this.isLoadingState ? this.renderLoading() : html ``}
      </div>
    `;
    }
    /**
     * Reloads the component with its current settings and potential new data
     *
     * @memberof MgtAgenda
     */
    reload() {
        return __awaiter(this, void 0, void 0, function* () {
            this.events = yield this.loadEvents();
        });
    }
    /**
     * Render the loading state
     *
     * @protected
     * @returns
     * @memberof MgtAgenda
     */
    renderLoading() {
        return (this.renderTemplate('loading', null) ||
            html `
        <div class="event">
          <div class="event-time-container">
            <div class="event-time-loading loading-element"></div>
          </div>
          <div class="event-details-container">
            <div class="event-subject-loading loading-element"></div>
            <div class="event-location-container">
              <div class="event-location-icon-loading loading-element"></div>
              <div class="event-location-loading loading-element"></div>
            </div>
            <div class="event-location-container">
              <div class="event-attendee-loading loading-element"></div>
              <div class="event-attendee-loading loading-element"></div>
              <div class="event-attendee-loading loading-element"></div>
            </div>
          </div>
        </div>
      `);
    }
    /**
     * Clears state of the component
     *
     * @protected
     * @memberof MgtAgenda
     */
    clearState() {
        this.events = null;
    }
    /**
     * Render the no-data state.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtAgenda
     */
    renderNoData() {
        return this.renderTemplate('no-data', null) || html ``;
    }
    /**
     * Render an individual Event.
     *
     * @protected
     * @param {MicrosoftGraph.Event} event
     * @returns
     * @memberof MgtAgenda
     */
    renderEvent(event) {
        return html `
      <div class="event">
        <div class="event-time-container">
          <div class="event-time" aria-label="${this.getEventTimeString(event)}">${this.getEventTimeString(event)}</div>
        </div>
        <div class="event-details-container">
          ${this.renderTitle(event)} ${this.renderLocation(event)} ${this.renderAttendees(event)}
        </div>
        <div class="event-other-container">${this.renderOther(event)}</div>
      </div>
    `;
    }
    /**
     * Render the header for a group.
     * Only relevant for grouped Events.
     *
     * @protected
     * @param {Date} date
     * @returns
     * @memberof MgtAgenda
     */
    renderHeader(header) {
        return (this.renderTemplate('header', { header }, 'header-' + header) ||
            html `
        <div class="header" aria-label="${header}">${header}</div>
      `);
    }
    /**
     * Render the title field of an Event
     *
     * @protected
     * @param {MicrosoftGraph.Event} event
     * @returns
     * @memberof MgtAgenda
     */
    renderTitle(event) {
        return html `
      <div aria-label=${event.subject} class="event-subject">${event.subject}</div>
    `;
    }
    /**
     * Render the location field of an Event
     *
     * @protected
     * @param {MicrosoftGraph.Event} event
     * @returns
     * @memberof MgtAgenda
     */
    renderLocation(event) {
        if (!event.location.displayName) {
            return null;
        }
        return html `
      <div class="event-location-container">
        <div class="event-location-icon">${getSvg(SvgIcon.OfficeLocation)}</div>
        <div class="event-location" aria-label="${event.location.displayName}">${event.location.displayName}</div>
      </div>
    `;
    }
    /**
     * Render the attendees field of an Event
     *
     * @protected
     * @param {MicrosoftGraph.Event} event
     * @returns
     * @memberof MgtAgenda
     */
    renderAttendees(event) {
        if (!event.attendees.length) {
            return null;
        }
        return html `
      <mgt-people
        class="event-attendees"
        .peopleQueries=${event.attendees.map(attendee => {
            return attendee.emailAddress.address;
        })}
      ></mgt-people>
    `;
    }
    /**
     * Render the event other field of an Event
     *
     * @protected
     * @param {MicrosoftGraph.Event} event
     * @returns
     * @memberof MgtAgenda
     */
    renderOther(event) {
        return this.hasTemplate('event-other')
            ? html `
          ${this.renderTemplate('event-other', { event }, event.id + '-other')}
        `
            : null;
    }
    /**
     * Render the events in groups, each with a header.
     *
     * @protected
     * @param {MicrosoftGraph.Event[]} events
     * @returns {TemplateResult}
     * @memberof MgtAgenda
     */
    renderGroups(events) {
        // Render list, grouped by day
        const grouped = {};
        events.forEach(event => {
            var _a;
            let dateString = (_a = event === null || event === void 0 ? void 0 : event.start) === null || _a === void 0 ? void 0 : _a.dateTime;
            if (event.end.timeZone === 'UTC') {
                dateString += 'Z';
            }
            const header = this.getDateHeaderFromDateTimeString(dateString);
            grouped[header] = grouped[header] || [];
            grouped[header].push(event);
        });
        return html `
      ${Object.keys(grouped).map(header => html `
            <div class="group">${this.renderHeader(header)} ${this.renderEvents(grouped[header])}</div>
          `)}
    `;
    }
    /**
     * Render a list of events.
     *
     * @protected
     * @param {MicrosoftGraph.Event[]} events
     * @returns {TemplateResult}
     * @memberof MgtAgenda
     */
    renderEvents(events) {
        return html `
      <ul class="agenda-list">
        ${events.map(event => html `
              <li @click=${() => this.eventClicked(event)}>
                ${this.renderTemplate('event', { event }, event.id) || this.renderEvent(event)}
              </li>
            `)}
      </ul>
    `;
    }
    /**
     * Load state into the component
     *
     * @protected
     * @returns
     * @memberof MgtAgenda
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.events) {
                return;
            }
            const events = yield this.loadEvents();
            if (events && events.length > 0) {
                this.events = events;
            }
        });
    }
    reloadState() {
        return __awaiter(this, void 0, void 0, function* () {
            this.events = null;
            this.requestStateUpdate(true);
        });
    }
    onResize() {
        this._isNarrow = this.offsetWidth < 600;
    }
    eventClicked(event) {
        this.fireCustomEvent('eventClick', { event });
    }
    getEventTimeString(event) {
        if (event.isAllDay) {
            return 'ALL DAY';
        }
        // #937 When not specifying a preferred time zone using the
        // preferred-timezone attribute, MGT treats the dates retrieved from
        // Microsoft Graph as local time, rather than UTC.
        let startString = event.start.dateTime;
        if (event.start.timeZone === 'UTC') {
            startString += 'Z';
        }
        let endString = event.end.dateTime;
        if (event.end.timeZone === 'UTC') {
            endString += 'Z';
        }
        const start = this.prettyPrintTimeFromDateTime(new Date(startString));
        const end = this.prettyPrintTimeFromDateTime(new Date(endString));
        return `${start} - ${end}`;
    }
    loadEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            const p = Providers.globalProvider;
            let events = [];
            if (p && p.state === ProviderState.SignedIn) {
                const graph = p.graph.forComponent(this);
                if (this.eventQuery) {
                    try {
                        const tokens = this.eventQuery.split('|');
                        let scope;
                        let query;
                        if (tokens.length > 1) {
                            query = tokens[0].trim();
                            scope = tokens[1].trim();
                        }
                        else {
                            query = this.eventQuery;
                        }
                        let request = graph.api(query);
                        if (scope) {
                            request = request.middlewareOptions(prepScopes(scope));
                        }
                        const results = yield request.get();
                        if (results && results.value) {
                            events = results.value;
                        }
                        // tslint:disable-next-line: no-empty
                    }
                    catch (e) { }
                }
                else {
                    const start = this.date ? new Date(this.date) : new Date();
                    const end = new Date(start.getTime());
                    end.setDate(start.getDate() + this.days);
                    try {
                        const iterator = yield getEventsPageIterator(graph, start, end, this.groupId);
                        if (iterator && iterator.value) {
                            events = iterator.value;
                            while (iterator.hasNext) {
                                yield iterator.next();
                                events = iterator.value;
                            }
                        }
                    }
                    catch (error) {
                        // noop - possible error with graph
                    }
                }
            }
            return events;
        });
    }
    prettyPrintTimeFromDateTime(date) {
        return date.toLocaleTimeString(navigator.language, {
            timeStyle: 'short',
            timeZone: this.preferredTimezone
        });
    }
    getDateHeaderFromDateTimeString(dateTimeString) {
        const date = new Date(dateTimeString);
        return date.toLocaleDateString(navigator.language, {
            dateStyle: 'full',
            timeZone: this.preferredTimezone
        });
    }
};
__decorate([
    property({
        attribute: 'date',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtAgenda.prototype, "date", null);
__decorate([
    property({
        attribute: 'group-id',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtAgenda.prototype, "groupId", null);
__decorate([
    property({
        attribute: 'days',
        type: Number
    }),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Object])
], MgtAgenda.prototype, "days", null);
__decorate([
    property({
        attribute: 'event-query',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtAgenda.prototype, "eventQuery", null);
__decorate([
    property({
        attribute: 'events',
        type: Array
    }),
    __metadata("design:type", Array)
], MgtAgenda.prototype, "events", void 0);
__decorate([
    property({
        attribute: 'show-max',
        type: Number
    }),
    __metadata("design:type", Number)
], MgtAgenda.prototype, "showMax", void 0);
__decorate([
    property({
        attribute: 'group-by-day',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtAgenda.prototype, "groupByDay", void 0);
__decorate([
    property({
        attribute: 'preferred-timezone',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtAgenda.prototype, "preferredTimezone", null);
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Boolean)
], MgtAgenda.prototype, "_isNarrow", void 0);
MgtAgenda = __decorate([
    customElement('mgt-agenda'),
    __metadata("design:paramtypes", [])
], MgtAgenda);
export { MgtAgenda };
//# sourceMappingURL=mgt-agenda.js.map