/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes } from '@microsoft/mgt-element';
/**
 * async promise, allows developer to create new Planner task
 *
 * @param {(PlannerTask)} newTask
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function addPlannerTask(graph, newTask) {
    return graph
        .api('/planner/tasks')
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.ReadWrite.All'))
        .post(newTask);
}
/**
 * async promise, allows developer to assign people to task
 *
 * @param {string} taskId
 * @param {*} people
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function assignPeopleToPlannerTask(graph, taskId, people, eTag) {
    return setPlannerTaskDetails(graph, taskId, {
        assignments: people
    }, eTag);
}
/**
 * async promise, allows developer to remove Planner task associated with taskId
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function removePlannerTask(graph, taskId, eTag) {
    return graph
        .api(`/planner/tasks/${taskId}`)
        .header('Cache-Control', 'no-store')
        .header('If-Match', eTag)
        .middlewareOptions(prepScopes('Group.ReadWrite.All'))
        .delete();
}
/**
 * async promise, allows developer to set a task to complete, associated with taskId
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function setPlannerTaskComplete(graph, taskId, eTag) {
    return setPlannerTaskDetails(graph, taskId, {
        percentComplete: 100
    }, eTag);
}
/**
 * async promise, allows developer to set a task to incomplete, associated with taskId
 *
 * @param {string} taskId
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function setPlannerTaskIncomplete(graph, taskId, eTag) {
    return setPlannerTaskDetails(graph, taskId, {
        percentComplete: 0
    }, eTag);
}
/**
 * async promise, allows developer to set details of planner task associated with a taskId
 *
 * @param {string} taskId
 * @param {(PlannerTask)} details
 * @param {string} eTag
 * @returns {Promise<any>}
 * @memberof Graph
 */
export function setPlannerTaskDetails(graph, taskId, details, eTag) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield graph
            .api(`/planner/tasks/${taskId}`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.ReadWrite.All'))
            .header('If-Match', eTag)
            .patch(JSON.stringify(details));
    });
}
/**
 * async promise, returns all planner plans associated with the group id
 *
 * @param {string} groupId
 * @returns {(Promise<PlannerPlan[]>)}
 * @memberof Graph
 */
export function getPlansForGroup(graph, groupId) {
    return __awaiter(this, void 0, void 0, function* () {
        const scopes = 'Group.Read.All';
        const uri = `/groups/${groupId}/planner/plans`;
        const plans = yield graph.api(uri).header('Cache-Control', 'no-store').middlewareOptions(prepScopes(scopes)).get();
        return plans ? plans.value : null;
    });
}
/**
 * async promise, returns a single plan from the Graph associated with the planId
 *
 * @param {string} planId
 * @returns {(Promise<PlannerPlan>)}
 * @memberof Graph
 */
export function getSinglePlannerPlan(graph, planId) {
    return __awaiter(this, void 0, void 0, function* () {
        const plan = yield graph
            .api(`/planner/plans/${planId}`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.Read.All'))
            .get();
        return plan;
    });
}
/**
 * async promise, returns bucket (for tasks) associated with a planId
 *
 * @param {string} planId
 * @returns {(Promise<PlannerBucket[]>)}
 * @memberof Graph
 */
export function getBucketsForPlannerPlan(graph, planId) {
    return __awaiter(this, void 0, void 0, function* () {
        const buckets = yield graph
            .api(`/planner/plans/${planId}/buckets`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.Read.All'))
            .get();
        return buckets && buckets.value;
    });
}
/**
 * async promise, returns all planner plans associated with the user logged in
 *
 * @returns {(Promise<PlannerPlan[]>)}
 * @memberof Graph
 */
export function getAllMyPlannerPlans(graph) {
    return __awaiter(this, void 0, void 0, function* () {
        const plans = yield graph
            .api('/me/planner/plans')
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.Read.All'))
            .get();
        return plans && plans.value;
    });
}
/**
 * async promise, returns all tasks from planner associated with a bucketId
 *
 * @param {string} bucketId
 * @returns {(Promise<PlannerTask[][]>)}
 * @memberof Graph
 */
export function getTasksForPlannerBucket(graph, bucketId) {
    return __awaiter(this, void 0, void 0, function* () {
        const tasks = yield graph
            .api(`/planner/buckets/${bucketId}/tasks`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.Read.All'))
            .get();
        return tasks && tasks.value;
    });
}
//# sourceMappingURL=mgt-tasks.graph.planner.js.map