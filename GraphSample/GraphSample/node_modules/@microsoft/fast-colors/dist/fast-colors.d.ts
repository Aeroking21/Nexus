/**
 * Blend two colors.
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blend(mode: ColorBlendMode, bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * Blends two colors with the burn mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendBurn(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendBurnChannel(bottom: number, top: number): number;

/**
 * Blends two colors
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendColor(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * Blends two colors with the darken mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendDarken(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendDarkenChannel(bottom: number, top: number): number;

/**
 * Blends two colors with the dodge mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendDodge(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendDodgeChannel(bottom: number, top: number): number;

/**
 * Blends two colors with the lighten mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendLighten(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendLightenChannel(bottom: number, top: number): number;

/**
 * Blends two colors with the multiply mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendMultiply(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendMultiplyChannel(bottom: number, top: number): number;

/**
 * Blends two colors with the overlay mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendOverlay(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendOverlayChannel(bottom: number, top: number): number;

/**
 * Blends two colors with the screen mode
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function blendScreen(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * @public
 */
export declare function blendScreenChannel(bottom: number, top: number): number;

/**
 * Calculate an overlay color that uses rgba (rgb + alpha) that matches the appearance of a given solid color when placed on the same background
 * @param rgbMatch - The solid color the overlay should match in appearance when placed over the rgbBackground
 * @param rgbBackground - The background on which the overlay rests
 * @param rgbOverlay - The rgb color of the overlay. Typically this is either pure white or pure black and when not provided will be determined automatically. This color will be used in the returned output
 * @returns The rgba (rgb + alpha) color of the overlay
 *
 * @public
 */
export declare function calculateOverlayColor(rgbMatch: ColorRGBA64, rgbBackground: ColorRGBA64, rgbOverlay?: ColorRGBA64): ColorRGBA64;

/**
 * Takes an input array of colors and extrapolates them to a larger palette. The mapping first takes the input array and extrapolates between each color so that they are separated by spacing-1 slots. Then it adds to either end enough new colors to make up the desired targetSize. All output color slots between the defined stops are interpolated.
 * @example
 * For an input array with length 5, a targetSize of 17 and spacing of 3 the output would be:
 *  0: scaleColorLight
 *  1:
 *  2: input 0
 *  3:
 *  4:
 *  5: input 1
 *  6:
 *  7:
 *  8: input 2
 *  9:
 * 10:
 * 11: input 3
 * 12:
 * 13:
 * 14: input 4
 * 15:
 * 16: scaleColorDark
 *
 * @public
 */
export declare function centeredRescale(input: ColorRGBA64[], config?: CenteredRescaleConfig): ColorRGBA64[];

/**
 * @public
 */
export declare interface CenteredRescaleConfig {
    targetSize: number;
    spacing: number;
    scaleColorLight: ColorRGBA64;
    scaleColorDark: ColorRGBA64;
}

/**
 * Ensures that an input number does not exceed a max value and is not less than a min value.
 * @param i - the number to clamp
 * @param min - the maximum (inclusive) value
 * @param max - the minimum (inclusive) value
 * @public
 */
export declare function clamp(i: number, min: number, max: number): number;

/**
 * Color blend modes.
 * @public
 */
export declare enum ColorBlendMode {
    Burn = 0,
    Color = 1,
    Darken = 2,
    Dodge = 3,
    Lighten = 4,
    Multiply = 5,
    Overlay = 6,
    Screen = 7
}

/**
 * This uses Hue values in "degree" format. So expect a range of [0,360]. Some other implementations instead uses radians or a normalized Hue with range [0,1]. Be aware of this when checking values or using other libraries.
 *
 * @public
 */
export declare class ColorHSL {
    /**
     * Construct a {@link ColorHSL} from a config object.
     */
    static fromObject(data: {
        h: number;
        s: number;
        l: number;
    }): ColorHSL | null;
    constructor(hue: number, sat: number, lum: number);
    readonly h: number;
    readonly s: number;
    readonly l: number;
    /**
     * Determines if a color is equal to another
     * @param rhs - the value to compare
     */
    equalValue(rhs: ColorHSL): boolean;
    /**
     * Returns a new {@link ColorHSL} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorHSL;
    /**
     * Returns the {@link ColorHSL} formatted as an object.
     */
    toObject(): {
        h: number;
        s: number;
        l: number;
    };
}

/**
 * This uses Hue values in "degree" format. So expect a range of [0,360]. Some other implementations instead uses radians or a normalized Hue with range [0,1]. Be aware of this when checking values or using other libraries.
 *
 * @public
 */
export declare class ColorHSV {
    /**
     * Construct a {@link ColorHSV} from a config object.
     */
    static fromObject(data: {
        h: number;
        s: number;
        v: number;
    }): ColorHSV | null;
    constructor(hue: number, sat: number, val: number);
    readonly h: number;
    readonly s: number;
    readonly v: number;
    /**
     * Determines if a color is equal to another
     * @param rhs - the value to compare
     */
    equalValue(rhs: ColorHSV): boolean;
    /**
     * Returns a new {@link ColorHSV} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorHSV;
    /**
     * Returns the {@link ColorHSV} formatted as an object.
     */
    toObject(): {
        h: number;
        s: number;
        v: number;
    };
}

/**
 * Color interpolation spaces
 *
 * @public
 */
export declare enum ColorInterpolationSpace {
    RGB = 0,
    HSL = 1,
    HSV = 2,
    XYZ = 3,
    LAB = 4,
    LCH = 5
}

/**
 * {@link https://en.wikipedia.org/wiki/CIELAB_color_space | CIELAB color space}
 * This implementation uses the D65 constants for 2 degrees. That determines the constants used for the pure white point of the XYZ space of 0.95047, 1.0, 1.08883.
 * {@link https://en.wikipedia.org/wiki/Illuminant_D65}
 * These constants determine how the XYZ, LCH and LAB colors convert to/from RGB.
 *
 * @public
 */
export declare class ColorLAB {
    static readonly epsilon: number;
    static readonly kappa: number;
    /**
     * Construct a {@link ColorLAB} from a config object.
     */
    static fromObject(data: {
        l: number;
        a: number;
        b: number;
    }): ColorLAB | null;
    constructor(l: number, a: number, b: number);
    readonly l: number;
    readonly a: number;
    readonly b: number;
    /**
     * Determines if a color is equal to another
     * @param rhs - the value to compare
     */
    equalValue(rhs: ColorLAB): boolean;
    /**
     * Returns a new {@link ColorLAB} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorLAB;
    /**
     * Returns the {@link ColorLAB} formatted as an object.
     */
    toObject(): {
        l: number;
        a: number;
        b: number;
    };
}

/**
 *
 * {@link https://en.wikipedia.org/wiki/CIELAB_color_space | CIELCH color space}
 *
 * This is a cylindrical representation of the CIELAB space useful for saturation operations
 * This uses Hue values in "degree" format. So expect a range of [0,360]. Some other implementations instead uses radians or a normalized Hue with range [0,1]. Be aware of this when checking values or using other libraries.
 * This implementation uses the D65 constants for 2 degrees. That determines the constants used for the pure white point of the XYZ space of 0.95047, 1.0, 1.08883.
 * {@link https://en.wikipedia.org/wiki/Illuminant_D65}
 * These constants determine how the XYZ, LCH and LAB colors convert to/from RGB.
 *
 * @public
 */
export declare class ColorLCH {
    /**
     * Construct a {@link ColorLCH} from a config object.
     * @param data - the config object
     */
    static fromObject(data: {
        l: number;
        c: number;
        h: number;
    }): ColorLCH | null;
    constructor(l: number, c: number, h: number);
    readonly l: number;
    readonly c: number;
    readonly h: number;
    /**
     * Determines if one color is equal to another.
     * @param rhs - the color to compare
     */
    equalValue(rhs: ColorLCH): boolean;
    /**
     * Returns a new {@link ColorLCH} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorLCH;
    /**
     * Converts the {@link ColorLCH} to a config object.
     */
    toObject(): {
        l: number;
        c: number;
        h: number;
    };
}

/**
 * Generates a color palette
 * @public
 */
export declare class ColorPalette {
    static readonly defaultPaletteConfig: ColorPaletteConfig;
    static readonly greyscalePaletteConfig: ColorPaletteConfig;
    constructor(config: ColorPaletteConfig);
    private readonly config;
    readonly palette: ColorRGBA64[];
    updatePaletteGenerationValues(newConfig: ColorPaletteConfig): boolean;
    private updatePaletteColors;
    generatePaletteColorScale(): ColorScale;
}

/**
 * @public
 */
export declare interface ColorPaletteConfig {
    baseColor?: ColorRGBA64;
    steps?: number;
    interpolationMode?: ColorInterpolationSpace;
    scaleColorLight?: ColorRGBA64;
    scaleColorDark?: ColorRGBA64;
    clipLight?: number;
    clipDark?: number;
    saturationAdjustmentCutoff?: number;
    saturationLight?: number;
    saturationDark?: number;
    overlayLight?: number;
    overlayDark?: number;
    multiplyLight?: number;
    multiplyDark?: number;
    baseScalePosition?: number;
}

/**
 * A RGBA color with 64 bit channels.
 *
 * @example
 * ```ts
 * new ColorRGBA64(1, 0, 0, 1) // red
 * ```
 * @public
 */
export declare class ColorRGBA64 {
    /**
     * Construct a {@link ColorRGBA64} from a {@link ColorRGBA64Config}
     * @param data - the config object
     */
    static fromObject(data: ColorRGBA64Config): ColorRGBA64 | null;
    /**
     *
     * @param red - the red value
     * @param green - the green value
     * @param blue - the blue value
     * @param alpha - the alpha value
     */
    constructor(red: number, green: number, blue: number, alpha?: number);
    /**
     * The red value
     * @remarks
     * Scaled to the range [0.0 , 1.0]. Values outside this range are allowed but any methods that convert or tostring the values will also be clamped
     */
    readonly r: number;
    /**
     * The green value
     * @remarks
     * Scaled to the range [0.0 , 1.0]. Values outside this range are allowed but any methods that convert or tostring the values will also be clamped
     */
    readonly g: number;
    /**
     * The blue value
     * @remarks
     * Scaled to the range [0.0 , 1.0]. Values outside this range are allowed but any methods that convert or tostring the values will also be clamped
     */
    readonly b: number;
    /**
     * The alpha value
     * @remarks
     * Scaled to the range [0.0 , 1.0]. Values outside this range are allowed but any methods that convert or tostring the values will also be clamped
     */
    readonly a: number;
    /**
     * Determines if one color is equal to another.
     * @param rhs - the color to compare
     */
    equalValue(rhs: ColorRGBA64): boolean;
    /**
     * Returns the color formatted as a string; #RRGGBB
     */
    toStringHexRGB(): string;
    /**
     * Returns the color formatted as a string; #RRGGBBAA
     */
    toStringHexRGBA(): string;
    /**
     * Returns the color formatted as a string; #AARRGGBB
     */
    toStringHexARGB(): string;
    /**
     * Returns the color formatted as a string; "rgb(0xRR, 0xGG, 0xBB)"
     */
    toStringWebRGB(): string;
    /**
     * Returns the color formatted as a string; "rgba(0xRR, 0xGG, 0xBB, a)"
     * @remarks
     * Note that this follows the convention of putting alpha in the range [0.0,1.0] while the other three channels are [0,255]
     */
    toStringWebRGBA(): string;
    /**
     * Returns a new {@link ColorRGBA64} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorRGBA64;
    /**
     * Returns a new {@link ColorRGBA64} with channel values clamped between 0 and 1.
     */
    clamp(): ColorRGBA64;
    /**
     * Converts the {@link ColorRGBA64} to a {@link ColorRGBA64Config}.
     */
    toObject(): Required<ColorRGBA64Config>;
    private formatHexValue;
}

/**
 * Configuration object for {@link ColorRGBA64}
 * @public
 */
export declare interface ColorRGBA64Config {
    r: number;
    g: number;
    b: number;
    a?: number;
}

/**
 * A color scale created from linear stops
 * @public
 */
export declare class ColorScale {
    static createBalancedColorScale(colors: ColorRGBA64[]): ColorScale;
    constructor(stops: ColorScaleStop[]);
    private readonly stops;
    getColor(position: number, interpolationMode?: ColorInterpolationSpace): ColorRGBA64;
    trim(lowerBound: number, upperBound: number, interpolationMode?: ColorInterpolationSpace): ColorScale;
    findNextColor(position: number, contrast: number, searchDown?: boolean, interpolationMode?: ColorInterpolationSpace, contrastErrorMargin?: number, maxSearchIterations?: number): number;
    clone(): ColorScale;
    private sortColorScaleStops;
}

/**
 * @public
 */
export declare interface ColorScaleStop {
    color: ColorRGBA64;
    position: number;
}

/**
 * {@link https://en.wikipedia.org/wiki/CIE_1931_color_space | XYZ color space}
 *
 * This implementation uses the D65 constants for 2 degrees. That determines the constants used for the pure white point of the XYZ space of 0.95047, 1.0, 1.08883.
 * {@link https://en.wikipedia.org/wiki/Illuminant_D65}
 * These constants determine how the XYZ, LCH and LAB colors convert to/from RGB.
 *
 * @public
 */
export declare class ColorXYZ {
    /**
     * D65 2 degree white point
     */
    static readonly whitePoint: ColorXYZ;
    /**
     * Construct a {@link ColorXYZ} from a config object.
     */
    static fromObject(data: {
        x: number;
        y: number;
        z: number;
    }): ColorXYZ | null;
    constructor(x: number, y: number, z: number);
    readonly x: number;
    readonly y: number;
    readonly z: number;
    /**
     * Determines if a color is equal to another
     * @param rhs - the value to compare
     */
    equalValue(rhs: ColorXYZ): boolean;
    /**
     * Returns a new {@link ColorXYZ} rounded to the provided precision
     * @param precision - the precision to round to
     */
    roundToPrecision(precision: number): ColorXYZ;
    /**
     * Returns the {@link ColorXYZ} formatted as an object.
     */
    toObject(): {
        x: number;
        y: number;
        z: number;
    };
}

/**
 * Creates a color palette for UI components
 * @public
 */
export declare class ComponentStateColorPalette {
    static readonly defaultPaletteConfig: ComponentStateColorPaletteConfig;
    palette: ColorRGBA64[];
    private readonly config;
    constructor(config?: ComponentStateColorPaletteConfig);
    private regenPalettes;
    private matchRelativeLuminanceIndex;
}

/**
 * Configuration for {@link ComponentStateColorPalette}
 * @public
 */
export declare interface ComponentStateColorPaletteConfig {
    /**
     * The color to create the palette from
     */
    baseColor?: ColorRGBA64;
    /**
     * The number of steps in the palette
     */
    steps?: number;
}

/**
 * Alpha channel of bottom is ignored
 * The returned color always has an alpha channel of 1
 * Different programs (eg: paint.net, photoshop) will give different answers than this occasionally but within +/- 1/255 in each channel. Just depends on the details of how they round off decimals
 *
 * @public
 */
export declare function computeAlphaBlend(bottom: ColorRGBA64, top: ColorRGBA64): ColorRGBA64;

/**
 * Calculate the contrast ratio between two colors. Uses the formula described by {@link https://www.w3.org/TR/WCAG20-TECHS/G17.html | WCAG 2.0}.
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function contrastRatio(a: ColorRGBA64, b: ColorRGBA64): number;

/**
 * Darken a color using LAB color space
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function darkenViaLAB(input: ColorRGBA64, amount: number, darkenConstant?: number): ColorRGBA64;

/**
 * @public
 */
export declare const defaultCenteredRescaleConfig: CenteredRescaleConfig;

/**
 * The default configuration for palette extraction.
 * @public
 */
export declare const defaultPaletteExtractionConfig: PaletteExtractionConfig;

/**
 * The default quantize configuration.
 * @public
 */
export declare const defaultQuantizeConfig: QuantizeConfig;

/**
 * Converts degrees to radians.
 * @param i - degrees
 * @public
 */
export declare function degreesToRadians(i: number): number;

/**
 * Scales a number between 0 and 1
 * @param i - the number to denormalize
 * @param min - the min value
 * @param max - the max value
 * @public
 */
export declare function denormalize(i: number, min: number, max: number): number;

/**
 * De-saturate a color using LCH color space
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function desaturateViaLCH(input: ColorRGBA64, saturation: number, saturationConstant?: number): ColorRGBA64;

/**
 * Extracts a palette.
 * @param colors - the quantized colors
 * @param config - the extraction config
 * @public
 */
export declare function extractPalette(colors: QuantizedColor[], config?: PaletteExtractionConfig): PaletteEntry[];

/**
 * Generates a greyscale palette using greyscaleConfig. The Lightness (in HSL) of the input color is then compared to the greyscale palette to determine how far off center the input color should be placed. The output palette is then generated with outputSteps number of steps using colorConfig.
 * @public
 */
export declare function generateOffCenterPalette(input: ColorRGBA64, outputSteps: number, greyscaleConfig?: ColorPaletteConfig, colorConfig?: ColorPaletteConfig): ColorPalette;

/**
 * Generates two palettes of length shortPaletteLength and longPaletteLength from a base color. The base color is compared to the default greyscale palette to determine where it should be placed. The short palette is then fed into centeredRescale to create the long palette. The colors in the short palette are always contained within the long.
 * @public
 */
export declare function generateScaledPalettes(input: ColorRGBA64, shortPaletteLength?: number, config?: CenteredRescaleConfig): {
    short: ColorRGBA64[];
    long: ColorRGBA64[];
};

/**
 * Converts a number between 0 and 255 to a hex string.
 * @param i - the number to convert to a hex string
 * @public
 */
export declare function getHexStringForByte(i: number): string;

/**
 * For each possible color, this counts how many pixels in the source image match that color.
 * If signifigantBits is less than 8, each channel (eg: red, green, blue) in each color is reduced to fit in significantBits. So for the default value of 5 significantBits colors are reduced from 8 bits per channel (0-255) to 5 (0-31). Colors that were previously distinct get combined together.
 * If the image source has more than 2^32 pixels (eg: a square image 65536x65536 in size) of the same color this code will break.
 *
 * @public
 */
export declare class Histogram {
    /**
     * @param source - the source pixel data.
     * @param significantBits - The memory needed for the histogram increases dramatically if significantBits is increased. It needs a buffer which is 4*2^(3*significantBits) in size. EG: for 5 significant bits the histogram is 128K while for 8 it is 64 megs.
     * @param pixelSkipping - CPU time increases linearly as pixelSkipping is reduced.
     * @param isHistogramPixelValid - isHistogramPixelValid is an optional predicate which can screen out unwanted pixels from the source data. EG: ignoring transparent pixels.
     */
    constructor(source: PixelBlob, significantBits?: number, pixelSkipping?: number, isHistogramPixelValid?: ((pixel: number[]) => boolean) | null);
    readonly data: Uint32Array;
    readonly significantBits: number;
    readonly total: number;
    readonly minRed: number;
    readonly maxRed: number;
    readonly minGreen: number;
    readonly maxGreen: number;
    readonly minBlue: number;
    readonly maxBlue: number;
    getHistogramIndex: (r: number, g: number, b: number) => number;
    getHistogramValue: (r: number, g: number, b: number) => number;
    setHistogramValue: (value: number, r: number, g: number, b: number) => void;
}

/**
 * Converts a {@link @microsoft/fast-colors#ColorHSL} to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param hsl - the hsl color to convert
 * @param alpha - the alpha value
 *
 * @public
 */
export declare function hslToRGB(hsl: ColorHSL, alpha?: number): ColorRGBA64;

/**
 * Converts a {@link @microsoft/fast-colors#ColorHSV} to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param hsv - the hsv color to convert
 * @param alpha - the alpha value
 *
 * @public
 */
export declare function hsvToRGB(hsv: ColorHSV, alpha?: number): ColorRGBA64;

/**
 * A {@link PixelBlob} implementation from an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageData | ImageData} object.
 * @public
 * @privateRemarks
 * Note that this class and the function loadImageData are not covered by unit tests
 * due to not being able to create a valid canvas rendering context or ImageData object
 * in the unit test framework. ArrayPixelBlob is used instead in tests needing a PixelBlob.
 */
export declare class ImageDataPixelBlob implements PixelBlob {
    constructor(image: ImageData);
    private image;
    readonly width: number;
    readonly height: number;
    readonly totalPixels: number;
    getPixel: (x: number, y: number) => ColorRGBA64;
    getPixelRGBA: (x: number, y: number) => number[];
}

/**
 * Adds a newItem to an already sorted list without needing to do a full re-sort.
 * Higher sort priority puts the newItem closer to the start (index 0) of the list.
 *
 * @public
 */
export declare function insertIntoSortedList(list: PixelBox[], newItem: PixelBox, sortPriority: (box: PixelBox) => number): void;

/**
 * Interpolate by color space
 *
 * @public
 */
export declare function interpolateByColorSpace(position: number, space: ColorInterpolationSpace, left: ColorRGBA64, right: ColorRGBA64): ColorRGBA64;

/**
 * Interpolate by HSL color space
 *
 * @public
 */
export declare function interpolateHSL(position: number, left: ColorHSL, right: ColorHSL): ColorHSL;

/**
 * Interpolate by HSV color space
 *
 * @public
 */
export declare function interpolateHSV(position: number, left: ColorHSV, right: ColorHSV): ColorHSV;

/**
 * Interpolate by LAB color space
 *
 * @public
 */
export declare function interpolateLAB(position: number, left: ColorLAB, right: ColorLAB): ColorLAB;

/**
 * Interpolate by LCH color space
 *
 * @public
 */
export declare function interpolateLCH(position: number, left: ColorLCH, right: ColorLCH): ColorLCH;

/**
 * Interpolate by RGB color space
 *
 * @public
 */
export declare function interpolateRGB(position: number, left: ColorRGBA64, right: ColorRGBA64): ColorRGBA64;

/**
 * Interpolate by XYZ color space
 *
 * @public
 */
export declare function interpolateXYZ(position: number, left: ColorXYZ, right: ColorXYZ): ColorXYZ;

/**
 * Tests whether a color is in {@link @microsoft/fast-colors#NamedColors}.
 * @param raw - the color name to test
 * @public
 */
export declare function isColorNamed(raw: string | NamedColors): raw is NamedColors;

/**
 * Test if a color matches #AARRGGBB or #ARGB
 * @public
 */
export declare function isColorStringHexARGB(raw: string): boolean;

/**
 * Test if a color matches #RRGGBB or #RGB
 * @public
 */
export declare function isColorStringHexRGB(raw: string): boolean;

/**
 * Test if a color matches #RRGGBBAA or #RGBA
 * @public
 */
export declare function isColorStringHexRGBA(raw: string): boolean;

/**
 * Test if a color matches rgb(rr, gg, bb)
 * @public
 */
export declare function isColorStringWebRGB(raw: string): boolean;

/**
 * Test if a color matches rgba(rr, gg, bb, aa)
 *
 * @public
 */
export declare function isColorStringWebRGBA(raw: string): boolean;

/**
 * Converts a {@link @microsoft/fast-colors#ColorLAB} to a {@link @microsoft/fast-colors#ColorLCH}
 * @param lab - the lab color to convert
 *
 * @remarks
 * The discontinuity in the C parameter at 0 means that floating point errors will often result in values near 0 giving unpredictable results.
 * EG: 0.0000001 gives a very different result than -0.0000001
 * In cases where both a and b are very near zero this function will return an LCH color with an H of 0
 * More info about the atan2 function: {@link https://en.wikipedia.org/wiki/Atan2}
 * @public
 */
export declare function labToLCH(lab: ColorLAB): ColorLCH;

/**
 * Converts a {@link @microsoft/fast-colors#ColorLAB} to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param lab - the LAB color to convert
 * @param alpha - the alpha value
 *
 * @remarks
 * Note that the xyz color space (which the conversion from LAB uses) is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0
 *
 * @public
 */
export declare function labToRGB(lab: ColorLAB, alpha?: number): ColorRGBA64;

/**
 * Converts a {@link @microsoft/fast-colors#ColorLAB} to a {@link @microsoft/fast-colors#ColorXYZ}
 * @param lab - the lab color to convert
 *
 * @public
 */
export declare function labToXYZ(lab: ColorLAB): ColorXYZ;

/**
 * Converts a {@link @microsoft/fast-colors#ColorLCH} to a {@link @microsoft/fast-colors#ColorLAB}
 * @param lch - the lch color to convert
 *
 * @public
 */
export declare function lchToLAB(lch: ColorLCH): ColorLAB;

/**
 * Convert a {@link @microsoft/fast-colors#ColorLCH} to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param lch - the LCH color to convert
 * @param alpha - the alpha value
 *
 * @public
 */
export declare function lchToRGB(lch: ColorLCH, alpha?: number): ColorRGBA64;

/**
 * Linearly interpolate
 * @public
 */
export declare function lerp(i: number, min: number, max: number): number;

/**
 * Linearly interpolate angles in degrees
 * @public
 */
export declare function lerpAnglesInDegrees(i: number, min: number, max: number): number;

/**
 * Linearly interpolate angles in radians
 * @public
 */
export declare function lerpAnglesInRadians(i: number, min: number, max: number): number;

/**
 * Lighten a color using LAB color space
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function lightenViaLAB(input: ColorRGBA64, amount: number, darkenConstant?: number): ColorRGBA64;

/**
 * Creates an HTMLImageElement and loads the source argument as its src. Then an HTMLCanvasElement is created and the image is copied into the canvas. The pixel data is then returned from the CanvasRenderingContext2D for that canvas.
 *
 * @public
 */
export declare function loadImageData(source: string): Promise<ImageData>;

/**
 * Takes the input color and compares it to each color in the reference array to find the index with the closest Lightness value in HSL color space
 * @public
 */
export declare function matchLightnessIndex(input: ColorRGBA64, reference: ColorRGBA64[]): number;

/**
 * Browser {@link https://www.w3schools.com/colors/colors_names.asp | named colors}.
 * @public
 */
export declare type NamedColors = "aliceblue" | "antiquewhite" | "aqua" | "aquamarine" | "azure" | "beige" | "bisque" | "black" | "blanchedalmond" | "blue" | "blueviolet" | "brown" | "burlywood" | "cadetblue" | "chartreuse" | "chocolate" | "coral" | "cornflowerblue" | "cornsilk" | "crimson" | "cyan" | "darkblue" | "darkcyan" | "darkgoldenrod" | "darkgray" | "darkgreen" | "darkgrey" | "darkkhaki" | "darkmagenta" | "darkolivegreen" | "darkorange" | "darkorchid" | "darkred" | "darksalmon" | "darkseagreen" | "darkslateblue" | "darkslategray" | "darkslategrey" | "darkturquoise" | "darkviolet" | "deeppink" | "deepskyblue" | "dimgray" | "dimgrey" | "dodgerblue" | "firebrick" | "floralwhite" | "forestgreen" | "fuchsia" | "gainsboro" | "ghostwhite" | "gold" | "goldenrod" | "gray" | "green" | "greenyellow" | "grey" | "honeydew" | "hotpink" | "indianred" | "indigo" | "ivory" | "khaki" | "lavender" | "lavenderblush" | "lawngreen" | "lemonchiffon" | "lightblue" | "lightcoral" | "lightcyan" | "lightgoldenrodyellow" | "lightgray" | "lightgreen" | "lightgrey" | "lightpink" | "lightsalmon" | "lightseagreen" | "lightskyblue" | "lightslategray" | "lightslategrey" | "lightsteelblue" | "lightyellow" | "lime" | "limegreen" | "linen" | "magenta" | "maroon" | "mediumaquamarine" | "mediumblue" | "mediumorchid" | "mediumpurple" | "mediumseagreen" | "mediumslateblue" | "mediumspringgreen" | "mediumturquoise" | "mediumvioletred" | "midnightblue" | "mintcream" | "mistyrose" | "moccasin" | "navajowhite" | "navy" | "oldlace" | "olive" | "olivedrab" | "orange" | "orangered" | "orchid" | "palegoldenrod" | "palegreen" | "paleturquoise" | "palevioletred" | "papayawhip" | "peachpuff" | "peru" | "pink" | "plum" | "powderblue" | "purple" | "red" | "rosybrown" | "royalblue" | "saddlebrown" | "salmon" | "sandybrown" | "seagreen" | "seashell" | "sienna" | "silver" | "skyblue" | "slateblue" | "slategray" | "slategrey" | "snow" | "springgreen" | "steelblue" | "tan" | "teal" | "thistle" | "tomato" | "transparent" | "turquoise" | "violet" | "wheat" | "white" | "whitesmoke" | "yellow" | "yellowgreen";

declare const namedColorsConfigs: {
    [name in NamedColors]: ColorRGBA64Config;
};

/**
 * Scales an input to a number between 0 and 1
 * @param i - a number between min and max
 * @param min - the max value
 * @param max - the min value
 * @public
 */
export declare function normalize(i: number, min: number, max: number): number;

/**
 * @public
 */
export declare interface PaletteEntry {
    found: boolean;
    constraint: PaletteEntryConstraint;
    color?: QuantizedColor;
}

/**
 * @public
 */
export declare interface PaletteEntryConstraint {
    id: string;
    targetSaturation: number;
    minSaturation: number;
    maxSaturation: number;
    targetLuminosity: number;
    minLuminosity: number;
    maxLuminosity: number;
}

/**
 * Configuration structure for palette extraction.
 * @public
 */
export declare interface PaletteExtractionConfig {
    saturationWeight: number;
    luminosityWeight: number;
    populationWeight: number;
    volumeWeight: number;
    constraints: PaletteEntryConstraint[];
}

/**
 *
 Expects any of the following and attempts to determine which is being used
 * #RRGGBB, #AARRGGBB, rgb(RR,GG,BB) rgba(RR,GG,BB,a),
 * or any of the {@link https://www.w3schools.com/colors/colors_names.asp | CSS color names}.
 * @param raw - the color string to parse
 * @public
 */
export declare function parseColor(raw: string): ColorRGBA64 | null;

/**
 * Converts a hexadecimal color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a color string in the form of "#AARRGGBB" or "#ARGB"
 * @example
 * ```ts
 * parseColorHexRGBA("#AAFF0000");
 * parseColorHexRGBA("#AF00");
 * ```
 * @public
 */
export declare function parseColorHexARGB(raw: string): ColorRGBA64 | null;

/**
 * Converts a hexadecimal color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a color string in the form of "#RRGGBB" or "#RGB"
 * @example
 * ```ts
 * parseColorHexRGBA("#FF0000");
 * parseColorHexRGBA("#F00");
 * ```
 * @public
 */
export declare function parseColorHexRGB(raw: string): ColorRGBA64 | null;

/**
 * Converts a hexadecimal color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a color string in the form of "#RRGGBBAA" or "#RGBA"
 * @example
 * ```ts
 * parseColorHexRGBA("#FF0000AA");
 * parseColorHexRGBA("#F00A");
 * ```
 * @public
 */
export declare function parseColorHexRGBA(raw: string): ColorRGBA64 | null;

/**
 * Converts a named color to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a {@link https://www.w3schools.com/colors/colors_names.asp | CSS color name}.
 * @example
 * ```ts
 * parseColorNamed("red");
 * ```
 * @public
 */
export declare function parseColorNamed(raw: keyof typeof namedColorsConfigs): ColorRGBA64 | null;

/**
 * Converts a rgb color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a color string format "rgba(RR,GG,BB)" where RR,GG,BB are [0,255]
 * @example
 * ```ts
 * parseColorWebRGB("rgba(255, 0, 0");
 * ```
 * @public
 */
export declare function parseColorWebRGB(raw: string): ColorRGBA64 | null;

/**
 * Converts a rgba color string to a {@link @microsoft/fast-colors#ColorRGBA64}.
 * @param raw - a color string format "rgba(RR,GG,BB,a)" where RR,GG,BB are [0,255] and a is [0,1]
 * @example
 * ```ts
 * parseColorWebRGBA("rgba(255, 0, 0, 1");
 * ```
 * @public
 */
export declare function parseColorWebRGBA(raw: string): ColorRGBA64 | null;

/**
 * Represents a blob of pixel data.
 *
 * @public
 */
export declare interface PixelBlob {
    width: number;
    height: number;
    totalPixels: number;
    getPixel(x: number, y: number): ColorRGBA64;
    /**
     * Returns an array of 4 numbers in the range [0,255] in order RGBA
     */
    getPixelRGBA(x: number, y: number): number[];
}

/**
 * Represents a range of colors in RGB color space.
 *
 * @public
 */
export declare class PixelBox {
    constructor(globalHistogram: Histogram, minRed: number, maxRed: number, minGreen: number, maxGreen: number, minBlue: number, maxBlue: number);
    readonly globalHistogram: Histogram;
    readonly pixelCount: number;
    readonly minRed: number;
    readonly maxRed: number;
    readonly rangeRed: number;
    readonly minGreen: number;
    readonly maxGreen: number;
    readonly rangeGreen: number;
    readonly minBlue: number;
    readonly maxBlue: number;
    readonly rangeBlue: number;
    readonly colorVolume: number;
    readonly averageColor: ColorRGBA64;
    /**
     * Attempts to divide the range of colors represented by this PixelBox into two smaller PixelBox objects.
     * This does not actually cut directly at the median, rather it finds the median then cuts halfway through the larger box on either side of that median. The result is that small areas of color are better represented in the final output.
     * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c
     */
    modifiedMedianCut: () => [PixelBox | null, PixelBox | null];
}

/**
 * The image stored in the source PixelBlob is reduced down to a small set of colors.
 * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c
 *
 * @public
 */
export declare function quantize(source: PixelBlob, config?: QuantizeConfig): QuantizedColor[];

/**
 * A quantize configuration object.
 * @public
 */
export declare interface QuantizeConfig {
    /**
     * Must be in the range [1,8]. Memory use increases as 4*2^(3*significantBits). Setting significantBits to 8 requires a 64 megabyte histogram.
     */
    significantBits: number;
    /**
     * Lowering this value increases the CPU load but includes more pixels in the calculation.
     */
    pixelSkipping: number;
    /**
     * Desired output palette size. Actual output may vary in edge cases such as images with very few colors.
     */
    targetPaletteSize: number;
    /**
     * For a final palette of size targetPaletteSize, we determine the first fractionByPopulation*targetPaletteSize using population as the only factor when determening sort order. For the rest of the colors the sort order is population*colorVolume. This helps highly contrasting colors in a small area to show up in some of the final output.
     */
    fractionByPopulation: number;
    /**
     * This predicate can be used to screen out undesirable colors from the final output. EG: excluding colors with a pixelCount below a min value.
     */
    isBoxValid: ((box: PixelBox) => boolean) | null;
    /**
     * This predicate can be used to exlude pixels from the histogram. It is passed numbers in the range [0,255] in rgba order. EG: Excluding colors too close to pure white or ones which are transparent.
     */
    isHistogramPixelValid: ((pixel: number[]) => boolean) | null;
    /**
     * If the quantization process goes on for more iterations than maxIterations it is aborted and the current results are returned. Only likely to happen in extreme edge cases with strange input.
     */
    maxIterations: number;
}

/**
 * A quantized color
 * @public
 */
export declare interface QuantizedColor {
    color: ColorRGBA64;
    pixelCount: number;
    colorVolume: number;
}

/**
 * The data in the color histogram is reduced down to a small set of colors.
 * It can be useful to create the Histogram manually in cases where one wants to remove or alter the colors in it
 * or to re-use it in order to quantize multiple times with different config settings.
 * Based on the Modified Median Cut Quantization implementation from https://github.com/DanBloomberg/leptonica/blob/master/src/colorquant2.c
 *
 * @public
 */
export declare function quantizeHistogram(histogram: Histogram, config?: QuantizeConfig): QuantizedColor[];

/**
 * Converts radians to degrees.
 * @param i - radians
 * @public
 */
export declare function radiansToDegrees(i: number): number;

/**
 * Take the input array of colors and extrapolates them to a larger palette of size targetSize. If preserveInputColors is false the input colors are evenly distributed into the output. Otherwise, the positions of the input colors are adjusted from a perfectly even distribution in order to ensure that the exact color values appearing in the input array also appear in the output array. The larger targetSize is compared to input.length the smaller those adjustments will be.
 *
 * @public
 */
export declare function rescale(input: ColorRGBA64[], targetSize: number, preserveInputColors: boolean): ColorRGBA64[];

/**
 * Converts a {@link @microsoft/fast-colors#ColorRGBA64} to a {@link @microsoft/fast-colors#ColorHSL}
 * @param rgb - the rgb color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function rgbToHSL(rgb: ColorRGBA64): ColorHSL;

/**
 * Converts a {@link @microsoft/fast-colors#ColorRGBA64} to a {@link @microsoft/fast-colors#ColorHSV}
 * @param rgb - the rgb color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function rgbToHSV(rgb: ColorRGBA64): ColorHSV;

/**
 * Converts a {@link @microsoft/fast-colors#ColorRGBA64} to a {@link @microsoft/fast-colors#ColorLAB}
 * @param rgb - the rgb color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function rgbToLAB(rgb: ColorRGBA64): ColorLAB;

/**
 * Convert a {@link @microsoft/fast-colors#ColorRGBA64} to a {@link @microsoft/fast-colors#ColorLCH}
 *
 * @param rgb - the rgb color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function rgbToLCH(rgb: ColorRGBA64): ColorLCH;

/**
 * Get the luminance of a color in the linear RGB space.
 * This is not the same as the relative luminance in the sRGB space for WCAG contrast calculations. Use rgbToRelativeLuminance instead.
 * @param rgb - The input color
 *
 * @public
 */
export declare function rgbToLinearLuminance(rgb: ColorRGBA64): number;

/**
 * Get the relative luminance of a color.
 * Adjusts the color to sRGB space, which is necessary for the WCAG contrast spec.
 * The alpha channel of the input is ignored.
 * @param rgb - The input color
 *
 * @public
 */
export declare function rgbToRelativeLuminance(rgb: ColorRGBA64): number;

/**
 * Convert a rgb color to a color temperature
 * @param rgb - the color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function rgbToTemperature(rgb: ColorRGBA64): number;

/**
 * Converts a {@link @microsoft/fast-colors#ColorRGBA64} to a {@link @microsoft/fast-colors#ColorXYZ}
 * @param rgb - the rgb color to convert
 *
 * @remarks
 * The alpha channel of the input is ignored
 * @public
 */
export declare function rgbToXYZ(rgb: ColorRGBA64): ColorXYZ;

/**
 *
 * Will return infinity if i*10^(precision) overflows number
 * note that floating point rounding rules come into play here
 * so values that end up rounding on a .5 round to the nearest
 * even not always up so 2.5 rounds to 2
 * @param i - the number to round
 * @param precision - the precision to round to
 *
 * @public
 */
export declare function roundToPrecisionSmall(i: number, precision: number): number;

/**
 * Saturate a color using LCH color space
 *
 * @remarks
 * The alpha channel of the input is ignored
 *
 * @public
 */
export declare function saturateViaLCH(input: ColorRGBA64, saturation: number, saturationConstant?: number): ColorRGBA64;

/**
 * Converts a color temperature to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param tempKelvin - the temperature to convert
 * @param alpha - the alpha value
 *
 * @public
 */
export declare function temperatureToRGB(tempKelvin: number, alpha?: number): ColorRGBA64;

/**
 * Converts a {@link @microsoft/fast-colors#ColorXYZ} to a {@link @microsoft/fast-colors#ColorLAB}
 * @param xyz - the xyz color to convert
 *
 * @public
 */
export declare function xyzToLAB(xyz: ColorXYZ): ColorLAB;

/**
 * Converts a {@link @microsoft/fast-colors#ColorXYZ} to a {@link @microsoft/fast-colors#ColorRGBA64}
 * @param xyz - the xyz color to convert
 * @param alpha - the alpha value
 *
 * @remarks
 * Note that the xyz color space is significantly larger than sRGB. As such, this can return colors rgb values greater than 1 or less than 0
 * @public
 */
export declare function xyzToRGB(xyz: ColorXYZ, alpha?: number): ColorRGBA64;

export { }
