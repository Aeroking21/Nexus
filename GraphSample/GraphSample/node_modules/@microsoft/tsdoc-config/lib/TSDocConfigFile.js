"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSDocConfigFile = void 0;
const tsdoc_1 = require("@microsoft/tsdoc");
const fs = __importStar(require("fs"));
const resolve = __importStar(require("resolve"));
const path = __importStar(require("path"));
const ajv_1 = __importDefault(require("ajv"));
const jju = __importStar(require("jju"));
const ajv = new ajv_1.default({ verbose: true });
function initializeSchemaValidator() {
    const jsonSchemaPath = resolve.sync('@microsoft/tsdoc/schemas/tsdoc.schema.json', { basedir: __dirname });
    const jsonSchemaContent = fs.readFileSync(jsonSchemaPath).toString();
    const jsonSchema = jju.parse(jsonSchemaContent, { mode: 'cjson' });
    return ajv.compile(jsonSchema);
}
// Warning: AJV has a fairly strange API.  Each time this function is called, the function  object's
// properties get overwritten with the results of the latest validation.  Thus we need to be careful
// to read the properties before a subsequent call may occur.
const tsdocSchemaValidator = initializeSchemaValidator();
/**
 * Represents an individual `tsdoc.json` file.
 *
 * @public
 */
class TSDocConfigFile {
    constructor() {
        this.log = new tsdoc_1.ParserMessageLog();
        this._extendsFiles = [];
        this._filePath = '';
        this._fileNotFound = true;
        this._hasErrors = false;
        this._fileMTime = 0;
        this._tsdocSchema = '';
        this._extendsPaths = [];
        this._tagDefinitions = [];
    }
    /**
     * Other config files that this file extends from.
     */
    get extendsFiles() {
        return this._extendsFiles;
    }
    /**
     * The full path of the file that was attempted to load.
     */
    get filePath() {
        return this._filePath;
    }
    /**
     * If true, then the TSDocConfigFile object contains an empty state, because the `tsdoc.json` file could
     * not be found by the loader.
     */
    get fileNotFound() {
        return this._fileNotFound;
    }
    /**
     * If true, then at least one error was encountered while loading this file or one of its "extends" files.
     *
     * @remarks
     * You can use {@link TSDocConfigFile.getErrorSummary} to report these errors.
     *
     * The individual messages can be retrieved from the {@link TSDocConfigFile.log} property of each `TSDocConfigFile`
     * object (including the {@link TSDocConfigFile.extendsFiles} tree).
     */
    get hasErrors() {
        return this._hasErrors;
    }
    /**
     * The `$schema` field from the `tsdoc.json` file.
     */
    get tsdocSchema() {
        return this._tsdocSchema;
    }
    /**
     * The `extends` field from the `tsdoc.json` file.  For the parsed file contents,
     * use the `extendsFiles` property instead.
     */
    get extendsPaths() {
        return this._extendsPaths;
    }
    get tagDefinitions() {
        return this._tagDefinitions;
    }
    /**
     * This can be used for cache eviction.  It returns true if the modification timestamp has changed for
     * any of the files that were read when loading this `TSDocConfigFile`, which indicates that the file should be
     * reloaded.  It does not consider cases where `TSDocConfigFile.fileNotFound` was `true`.
     *
     * @remarks
     * This can be used for cache eviction.  An example eviction strategy might be like this:
     *
     * - call `checkForModifiedFiles()` once per second, and reload the configuration if it returns true
     *
     * - otherwise, reload the configuration when it is more than 10 seconds old (to handle less common cases such
     *   as creation of a missing file, or creation of a file at an earlier location in the search path).
     */
    checkForModifiedFiles() {
        if (this._checkForModifiedFile()) {
            return true;
        }
        for (const extendsFile of this.extendsFiles) {
            if (extendsFile.checkForModifiedFiles()) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks the last modification time for `TSDocConfigFile.filePath` and returns `true` if it has changed
     * since the file was loaded.  If the file is missing, this returns `false`.  If the timestamp cannot be read,
     * then this returns `true`.
     */
    _checkForModifiedFile() {
        if (this._fileNotFound || !this._filePath) {
            return false;
        }
        try {
            const mtimeMs = fs.statSync(this._filePath).mtimeMs;
            return mtimeMs !== this._fileMTime;
        }
        catch (error) {
            return true;
        }
    }
    _reportError(parserMessageParameters) {
        this.log.addMessage(new tsdoc_1.ParserMessage(parserMessageParameters));
        this._hasErrors = true;
    }
    _loadJsonFile() {
        const configJsonContent = fs.readFileSync(this._filePath).toString();
        this._fileMTime = fs.statSync(this._filePath).mtimeMs;
        this._fileNotFound = false;
        const configJson = jju.parse(configJsonContent, { mode: 'cjson' });
        if (configJson.$schema !== TSDocConfigFile.CURRENT_SCHEMA_URL) {
            this._reportError({
                messageId: "tsdoc-config-unsupported-schema" /* ConfigFileUnsupportedSchema */,
                messageText: `Unsupported JSON "$schema" value; expecting "${TSDocConfigFile.CURRENT_SCHEMA_URL}"`,
                textRange: tsdoc_1.TextRange.empty,
            });
            return;
        }
        const success = tsdocSchemaValidator(configJson);
        if (!success) {
            const description = ajv.errorsText(tsdocSchemaValidator.errors);
            this._reportError({
                messageId: "tsdoc-config-schema-error" /* ConfigFileSchemaError */,
                messageText: 'Error loading config file: ' + description,
                textRange: tsdoc_1.TextRange.empty,
            });
            return;
        }
        this._tsdocSchema = configJson.$schema;
        if (configJson.extends) {
            this._extendsPaths.push(...configJson.extends);
        }
        for (const jsonTagDefinition of configJson.tagDefinitions || []) {
            let syntaxKind;
            switch (jsonTagDefinition.syntaxKind) {
                case 'inline':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.InlineTag;
                    break;
                case 'block':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.BlockTag;
                    break;
                case 'modifier':
                    syntaxKind = tsdoc_1.TSDocTagSyntaxKind.ModifierTag;
                    break;
                default:
                    // The JSON schema should have caught this error
                    throw new Error('Unexpected tag kind');
            }
            this._tagDefinitions.push(new tsdoc_1.TSDocTagDefinition({
                tagName: jsonTagDefinition.tagName,
                syntaxKind: syntaxKind,
                allowMultiple: jsonTagDefinition.allowMultiple,
            }));
        }
    }
    _loadWithExtends(configFilePath, referencingConfigFile, alreadyVisitedPaths) {
        if (!configFilePath) {
            this._reportError({
                messageId: "tsdoc-config-file-not-found" /* ConfigFileNotFound */,
                messageText: 'File not found',
                textRange: tsdoc_1.TextRange.empty,
            });
            return;
        }
        this._filePath = path.resolve(configFilePath);
        if (!fs.existsSync(this._filePath)) {
            this._reportError({
                messageId: "tsdoc-config-file-not-found" /* ConfigFileNotFound */,
                messageText: 'File not found',
                textRange: tsdoc_1.TextRange.empty,
            });
            return;
        }
        const hashKey = fs.realpathSync(this._filePath);
        if (referencingConfigFile && alreadyVisitedPaths.has(hashKey)) {
            this._reportError({
                messageId: "tsdoc-config-cyclic-extends" /* ConfigFileCyclicExtends */,
                messageText: `Circular reference encountered for "extends" field of "${referencingConfigFile.filePath}"`,
                textRange: tsdoc_1.TextRange.empty,
            });
            return;
        }
        alreadyVisitedPaths.add(hashKey);
        this._loadJsonFile();
        const configFileFolder = path.dirname(this.filePath);
        for (const extendsField of this.extendsPaths) {
            const resolvedExtendsPath = resolve.sync(extendsField, { basedir: configFileFolder });
            const baseConfigFile = new TSDocConfigFile();
            baseConfigFile._loadWithExtends(resolvedExtendsPath, this, alreadyVisitedPaths);
            if (baseConfigFile.fileNotFound) {
                this._reportError({
                    messageId: "tsdoc-config-unresolved-extends" /* ConfigFileUnresolvedExtends */,
                    messageText: `Unable to resolve "extends" reference to "${extendsField}"`,
                    textRange: tsdoc_1.TextRange.empty,
                });
            }
            this._extendsFiles.push(baseConfigFile);
            if (baseConfigFile.hasErrors) {
                this._hasErrors = true;
            }
        }
    }
    /**
     * For the given folder, look for the relevant tsdoc.json file (if any), and return its path.
     *
     * @param folderPath - the path to a folder where the search should start
     * @returns the (possibly relative) path to tsdoc.json, or an empty string if not found
     */
    static findConfigPathForFolder(folderPath) {
        if (folderPath) {
            let foundFolder = folderPath;
            for (;;) {
                const tsconfigJsonPath = path.join(foundFolder, 'tsconfig.json');
                if (fs.existsSync(tsconfigJsonPath)) {
                    // Stop when we reach a folder containing tsconfig.json
                    return path.join(foundFolder, TSDocConfigFile.FILENAME);
                }
                const packageJsonPath = path.join(foundFolder, 'package.json');
                if (fs.existsSync(packageJsonPath)) {
                    // Stop when we reach a folder containing package.json; this avoids crawling out of the current package
                    return path.join(foundFolder, TSDocConfigFile.FILENAME);
                }
                const previousFolder = foundFolder;
                foundFolder = path.dirname(foundFolder);
                if (!foundFolder || foundFolder === previousFolder) {
                    // Give up if we reach the filesystem root directory
                    break;
                }
            }
        }
        return '';
    }
    /**
     * Calls `TSDocConfigFile.findConfigPathForFolder()` to find the relevant tsdoc.json config file, if one exists.
     * Then calls `TSDocConfigFile.findConfigPathForFolder()` to return the loaded result.
     * @param folderPath - the path to a folder where the search should start
     */
    static loadForFolder(folderPath) {
        const rootConfigPath = TSDocConfigFile.findConfigPathForFolder(folderPath);
        return TSDocConfigFile.loadFile(rootConfigPath);
    }
    /**
     * Loads the specified tsdoc.json and any base files that it refers to using the "extends" option.
     * @param tsdocJsonFilePath - the path to the tsdoc.json config file
     */
    static loadFile(tsdocJsonFilePath) {
        const configFile = new TSDocConfigFile();
        const alreadyVisitedPaths = new Set();
        configFile._loadWithExtends(tsdocJsonFilePath, undefined, alreadyVisitedPaths);
        return configFile;
    }
    /**
     * Returns a report of any errors that occurred while attempting to load this file or any files
     * referenced via the "extends" field.
     *
     * @remarks
     * Use {@link TSDocConfigFile.hasErrors} to determine whether any errors occurred.
     */
    getErrorSummary() {
        if (!this._hasErrors) {
            return 'No errors.';
        }
        let result = `Errors encountered for ${this.filePath}:\n`;
        for (const message of this.log.messages) {
            result += `  ${message.text}\n`;
        }
        for (const extendsFile of this.extendsFiles) {
            if (extendsFile.hasErrors) {
                result += extendsFile.getErrorSummary();
            }
        }
        return result;
    }
    /**
     * Applies the settings from this config file to a TSDoc parser configuration.
     * Any `extendsFile` settings will also applied.
     */
    configureParser(configuration) {
        // First apply the base config files
        for (const extendsFile of this.extendsFiles) {
            extendsFile.configureParser(configuration);
        }
        // Then apply this one
        for (const tagDefinition of this.tagDefinitions) {
            configuration.addTagDefinition(tagDefinition);
        }
    }
}
exports.TSDocConfigFile = TSDocConfigFile;
TSDocConfigFile.FILENAME = 'tsdoc.json';
TSDocConfigFile.CURRENT_SCHEMA_URL = 'https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json';
//# sourceMappingURL=TSDocConfigFile.js.map