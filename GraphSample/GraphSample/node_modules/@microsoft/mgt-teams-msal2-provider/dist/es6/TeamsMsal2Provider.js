/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { InteractionRequiredAuthError } from '@azure/msal-browser';
import { LoginType, ProviderState, TeamsHelper } from '@microsoft/mgt-element';
import { Msal2Provider, PromptType } from '@microsoft/mgt-msal2-provider';
/**
 * Enumeration to define if we are using get or post
 *
 * @export
 * @enum {string}
 */
export var HttpMethod;
(function (HttpMethod) {
    /**
     * Will use Get and the querystring
     */
    HttpMethod["GET"] = "GET";
    /**
     * Will use Post and the request body
     */
    HttpMethod["POST"] = "POST";
})(HttpMethod || (HttpMethod = {}));
/**
 * Enables authentication of Single page apps inside of a Microsoft Teams tab
 *
 * @export
 * @class TeamsMsal2Provider
 * @extends {Msal2Provider}
 */
export class TeamsMsal2Provider extends Msal2Provider {
    /**
     * Gets whether the Teams provider can be used in the current context
     * (Whether the app is running in Microsoft Teams)
     *
     * @readonly
     * @static
     * @memberof TeamsMsal2Provider
     */
    static get isAvailable() {
        return TeamsHelper.isAvailable;
    }
    /**
     * Optional entry point to the teams library
     * If this value is not set, the provider will attempt to use
     * the microsoftTeams global variable.
     *
     * @static
     * @memberof TeamsMsal2Provider
     */
    static get microsoftTeamsLib() {
        return TeamsHelper.microsoftTeamsLib;
    }
    static set microsoftTeamsLib(value) {
        TeamsHelper.microsoftTeamsLib = value;
    }
    /**
     * Name used for analytics
     *
     * @readonly
     * @memberof IProvider
     */
    get name() {
        return 'MgtTeamsMsal2Provider';
    }
    /**
     * Handle all authentication redirects in the authentication page and authenticates the user
     *
     * @static
     * @returns
     * @memberof TeamsMsal2Provider
     */
    static handleAuth() {
        return __awaiter(this, void 0, void 0, function* () {
            // we are in popup world now - authenticate and handle it
            const teams = TeamsHelper.microsoftTeamsLib;
            if (!teams) {
                // tslint:disable-next-line: no-console
                console.error('Make sure you have referenced the Microsoft Teams sdk before using the TeamsMsal2Provider');
                return;
            }
            teams.initialize();
            // if we were signing out before, then we are done
            if (sessionStorage.getItem(this._sessionStorageLogoutInProgress)) {
                teams.authentication.notifySuccess();
            }
            const url = new URL(window.location.href);
            const isSignOut = url.searchParams.get('signout');
            const paramsString = localStorage.getItem(this._localStorageParametersKey);
            let authParams;
            if (paramsString) {
                authParams = JSON.parse(paramsString);
            }
            else {
                authParams = {};
            }
            if (!authParams.clientId) {
                teams.authentication.notifyFailure('no clientId provided');
                return;
            }
            const scopes = authParams.scopes ? authParams.scopes.split(',') : null;
            const prompt = authParams.isConsent ? PromptType.CONSENT : PromptType.SELECT_ACCOUNT;
            const options = authParams.options || { auth: { clientId: authParams.clientId } };
            options.system = options.system || {};
            options.system.loadFrameTimeout = 10000;
            const provider = new Msal2Provider({
                clientId: authParams.clientId,
                options,
                scopes,
                loginHint: authParams.loginHint,
                prompt: prompt
            });
            const handleProviderState = () => __awaiter(this, void 0, void 0, function* () {
                // how do we handle when user can't sign in
                // change to promise and return status
                if (provider.state === ProviderState.SignedOut) {
                    if (isSignOut) {
                        teams.authentication.notifySuccess();
                        return;
                    }
                    // make sure we are calling login only once
                    if (!sessionStorage.getItem(this._sessionStorageLoginInProgress)) {
                        const isInIframe = window.parent !== window;
                        if (!isInIframe) {
                            sessionStorage.setItem(this._sessionStorageLoginInProgress, 'true');
                        }
                        else {
                            console.warn('handleProviderState - Is in iframe... will try to login anyway... but will not set session storage variable');
                        }
                        provider.login();
                    }
                }
                else if (provider.state === ProviderState.SignedIn) {
                    if (isSignOut) {
                        sessionStorage.setItem(this._sessionStorageLogoutInProgress, 'true');
                        yield provider.logout();
                        return;
                    }
                    try {
                        const accessToken = yield provider.getAccessTokenForScopes(...provider.scopes);
                        teams.authentication.notifySuccess(accessToken);
                    }
                    catch (e) {
                        teams.authentication.notifyFailure(e);
                    }
                }
            });
            provider.onStateChanged(handleProviderState);
            handleProviderState();
        });
    }
    constructor(config) {
        super({
            clientId: config.clientId,
            loginType: LoginType.Redirect,
            options: config.msalOptions,
            scopes: config.scopes
        });
        this.clientId = config.clientId;
        this._msalOptions = config.msalOptions;
        this._authPopupUrl = config.authPopupUrl;
        this._ssoUrl = config.ssoUrl;
        this._autoConsent = typeof config.autoConsent !== 'undefined' ? config.autoConsent : true;
        this._httpMethod = typeof config.httpMethod !== 'undefined' ? config.httpMethod : HttpMethod.GET;
        const teams = TeamsHelper.microsoftTeamsLib;
        teams.initialize();
        // If we are in SSO-mode.
        if (this._ssoUrl) {
            this.internalLogin();
        }
    }
    /**
     * Opens the teams authentication popup to the authentication page
     *
     * @returns {Promise<void>}
     * @memberof TeamsMsal2Provider
     */
    login() {
        return __awaiter(this, void 0, void 0, function* () {
            // In SSO mode the login should not be able to be run via user click
            // this method is called from the SSO internal login process if we need to consent
            if (this._ssoUrl && !this._needsConsent) {
                return;
            }
            this.setState(ProviderState.Loading);
            const teams = TeamsHelper.microsoftTeamsLib;
            return new Promise((resolve, reject) => {
                teams.getContext(context => {
                    this.teamsContext = context;
                    const authParams = {
                        clientId: this.clientId,
                        loginHint: context.loginHint,
                        options: this._msalOptions,
                        scopes: this.scopes.join(','),
                        isConsent: this._autoConsent
                    };
                    localStorage.setItem(TeamsMsal2Provider._localStorageParametersKey, JSON.stringify(authParams));
                    const url = new URL(this._authPopupUrl, new URL(window.location.href));
                    teams.authentication.authenticate({
                        failureCallback: reason => {
                            this.setState(ProviderState.SignedOut);
                            reject();
                        },
                        successCallback: result => {
                            // If we are in SSO Mode, the consent has been successful. Consider logged in
                            if (this._ssoUrl) {
                                this.setState(ProviderState.SignedIn);
                                resolve();
                            }
                            else {
                                // Otherwise log in via MSAL
                                this.trySilentSignIn();
                                resolve();
                            }
                        },
                        url: url.href
                    });
                });
            });
        });
    }
    /**
     * sign out user
     *
     * @returns {Promise<void>}
     * @memberof MsalProvider
     */
    logout() {
        return __awaiter(this, void 0, void 0, function* () {
            // In SSO mode the logout should not be able to be run at all
            if (this._ssoUrl) {
                return;
            }
            const teams = TeamsHelper.microsoftTeamsLib;
            return new Promise((resolve, reject) => {
                teams.getContext(context => {
                    this.teamsContext = context;
                    const url = new URL(this._authPopupUrl, new URL(window.location.href));
                    url.searchParams.append('signout', 'true');
                    teams.authentication.authenticate({
                        failureCallback: reason => {
                            this.trySilentSignIn();
                            reject();
                        },
                        successCallback: result => {
                            this.trySilentSignIn();
                            resolve();
                        },
                        url: url.href
                    });
                });
            });
        });
    }
    /**
     * Returns an access token that can be used for making calls to the Microsoft Graph
     *
     * @param {AuthenticationProviderOptions} options
     * @returns {Promise<string>}
     * @memberof TeamsMsal2Provider
     */
    getAccessToken(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.teamsContext && TeamsHelper.microsoftTeamsLib) {
                const teams = TeamsHelper.microsoftTeamsLib;
                teams.initialize();
                this.teamsContext = yield this.getTeamsContext();
            }
            const scopes = options ? options.scopes || this.scopes : this.scopes;
            // If we are in SSO Mode
            if (this._ssoUrl) {
                // Get token via the Teams SDK
                const clientToken = yield this.getClientToken();
                let url = new URL(this._ssoUrl, new URL(window.location.href));
                let response;
                // Use GET and Query String
                if (this._httpMethod === HttpMethod.GET) {
                    const params = new URLSearchParams({
                        ssoToken: clientToken,
                        scopes: scopes.join(','),
                        clientId: this.clientId
                    });
                    response = yield fetch(`${url.href}?${params}`, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'default'
                    });
                }
                // Use POST and body
                else {
                    response = yield fetch(url.href, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            authorization: `Bearer ${clientToken}`
                        },
                        body: JSON.stringify({
                            scopes: scopes,
                            clientid: this.clientId
                        }),
                        mode: 'cors',
                        cache: 'default'
                    });
                }
                // Exchange token from server
                const data = yield response.json().catch(this.unhandledFetchError);
                if (!response.ok && data.error === 'consent_required') {
                    // A consent_required error means the user must consent to the requested scope, or use MFA
                    // If we are in the log in process, display a dialog
                    this._needsConsent = true;
                }
                else if (!response.ok) {
                    throw data;
                }
                else {
                    this._needsConsent = false;
                    return data.access_token;
                }
            }
            // If we are not in SSO Mode and using the Login component
            else {
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    const accessTokenRequest = {
                        scopes: scopes,
                        account: this.getAccount()
                    };
                    try {
                        const response = yield this.publicClientApplication.acquireTokenSilent(accessTokenRequest);
                        // return response.accessToken;
                        resolve(response.accessToken);
                    }
                    catch (e) {
                        if (e instanceof InteractionRequiredAuthError) {
                            // nothing we can do now until we can do incremental consent
                            // return null;
                            resolve(null);
                        }
                        else {
                            // throw e;
                            reject(e);
                        }
                    }
                }));
            }
        });
    }
    /**
     * Makes sure we can get an access token before considered logged in
     *
     * @returns {Promise<void>}
     * @memberof TeamsMsal2Provider
     */
    internalLogin() {
        return __awaiter(this, void 0, void 0, function* () {
            // Try to get access token
            const accessToken = yield this.getAccessToken(null);
            // If we have an access token. Consider the user signed in
            if (accessToken) {
                this.setState(ProviderState.SignedIn);
            }
            else {
                // If we need to consent to additional scopes
                if (this._needsConsent) {
                    // If autoconsent is configured. Display a popup where the user can consent
                    if (this._autoConsent) {
                        // We need to pass the scopes from the client side
                        if (!this.scopes) {
                            throw new Error('For auto consent, scopes must be provided');
                        }
                        else {
                            this.login();
                            return;
                        }
                    }
                    else {
                        throw new Error('Auto consent is not configured. You need to consent to additional scopes');
                    }
                }
            }
        });
    }
    /**
     * Get a token via the Teams SDK
     *
     * @returns {Promise<string>}
     * @memberof TeamsMsal2Provider
     */
    getClientToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const teams = TeamsHelper.microsoftTeamsLib;
            return new Promise((resolve, reject) => {
                teams.authentication.getAuthToken({
                    successCallback: (result) => {
                        resolve(result);
                    },
                    failureCallback: reason => {
                        this.setState(ProviderState.SignedOut);
                        reject();
                    }
                });
            });
        });
    }
    /**
     * Retrieves the Teams context
     */
    getTeamsContext() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                const teams = TeamsHelper.microsoftTeamsLib;
                teams.initialize();
                teams.getContext(context => {
                    resolve(context);
                    return;
                });
            });
        });
    }
    unhandledFetchError(err) {
        console.error(`There was an error during the server side token exchange: ${err}`);
    }
}
TeamsMsal2Provider._localStorageParametersKey = 'msg-TeamsMsal2Provider-auth-parameters';
TeamsMsal2Provider._sessionStorageLoginInProgress = 'msg-TeamsMsal2Provider-login-in-progress';
TeamsMsal2Provider._sessionStorageLogoutInProgress = 'msg-TeamsMsal2Provider-logout-in-progress';
//# sourceMappingURL=TeamsMsal2Provider.js.map