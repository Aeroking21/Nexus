/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { html, property } from 'lit-element';
import { equals } from '../utils/equals';
import { MgtBaseComponent } from './baseComponent';
import { TemplateHelper } from '../utils/TemplateHelper';
/**
 * An abstract class that defines a templatable web component
 *
 * @export
 * @abstract
 * @class MgtTemplatedComponent
 * @extends {MgtBaseComponent}
 *
 * @fires templateRendered - fires when a template is rendered
 */
export class MgtTemplatedComponent extends MgtBaseComponent {
    constructor() {
        super();
        /**
         * Holds all templates defined by developer
         *
         * @protected
         * @memberof MgtTemplatedComponent
         */
        this.templates = {};
        this._renderedSlots = false;
        this._renderedTemplates = {};
        this._slotNamesAddedDuringRender = [];
        this.templateContext = this.templateContext || {};
    }
    /**
     * Updates the element. This method reflects property values to attributes.
     * It can be overridden to render and keep updated element DOM.
     * Setting properties inside this method will *not* trigger
     * another update.
     *
     * * @param _changedProperties Map of changed properties with old values
     */
    update(changedProperties) {
        this.templates = this.getTemplates();
        this._slotNamesAddedDuringRender = [];
        super.update(changedProperties);
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param changedProperties Map of changed properties with old values
     */
    updated(changedProperties) {
        super.updated(changedProperties);
        this.removeUnusedSlottedElements();
    }
    /**
     * Render a <template> by type and return content to render
     *
     * @param templateType type of template (indicated by the data-type attribute)
     * @param context the data context that should be expanded in template
     * @param slotName the slot name that will be used to host the new rendered template. set to a unique value if multiple templates of this type will be rendered. default is templateType
     */
    renderTemplate(templateType, context, slotName) {
        if (!this.hasTemplate(templateType)) {
            return null;
        }
        slotName = slotName || templateType;
        this._slotNamesAddedDuringRender.push(slotName);
        this._renderedSlots = true;
        const template = html `
      <slot name=${slotName}></slot>
    `;
        const dataContext = Object.assign(Object.assign({}, context), this.templateContext);
        if (this._renderedTemplates.hasOwnProperty(slotName)) {
            const { context: existingContext, slot } = this._renderedTemplates[slotName];
            if (equals(existingContext, dataContext)) {
                return template;
            }
            this.removeChild(slot);
        }
        const div = document.createElement('div');
        div.slot = slotName;
        div.dataset.generated = 'template';
        TemplateHelper.renderTemplate(div, this.templates[templateType], dataContext);
        this.appendChild(div);
        this._renderedTemplates[slotName] = { context: dataContext, slot: div };
        this.fireCustomEvent('templateRendered', { templateType, context: dataContext, element: div });
        return template;
    }
    /**
     * Check if a specific template has been provided.
     *
     * @protected
     * @param {string} templateName
     * @returns {boolean}
     * @memberof MgtTemplatedComponent
     */
    hasTemplate(templateName) {
        return this.templates && this.templates[templateName];
    }
    getTemplates() {
        const templates = {};
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < this.children.length; i++) {
            const child = this.children[i];
            if (child.nodeName === 'TEMPLATE') {
                const template = child;
                if (template.dataset.type) {
                    templates[template.dataset.type] = template;
                }
                else {
                    templates.default = template;
                }
                template.templateOrder = i;
            }
        }
        return templates;
    }
    removeUnusedSlottedElements() {
        if (this._renderedSlots) {
            for (let i = 0; i < this.children.length; i++) {
                const child = this.children[i];
                if (child.dataset && child.dataset.generated && !this._slotNamesAddedDuringRender.includes(child.slot)) {
                    this.removeChild(child);
                    delete this._renderedTemplates[child.slot];
                    i--;
                }
            }
            this._renderedSlots = false;
        }
    }
}
__decorate([
    property({ attribute: false }),
    __metadata("design:type", Object)
], MgtTemplatedComponent.prototype, "templateContext", void 0);
//# sourceMappingURL=templatedComponent.js.map