/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { internalProperty, LitElement } from 'lit-element';
import { ProviderState } from '../providers/IProvider';
import { Providers } from '../providers/Providers';
import { LocalizationHelper } from '../utils/LocalizationHelper';
/**
 * Defines media query based on component width
 *
 * @export
 * @enum {string}
 */
export var ComponentMediaQuery;
(function (ComponentMediaQuery) {
    /**
     * devices with width < 768
     */
    ComponentMediaQuery["mobile"] = "";
    /**
     * devices with width < 1200
     */
    ComponentMediaQuery["tablet"] = "tablet";
    /**
     * devices with width > 1200
     */
    ComponentMediaQuery["desktop"] = "desktop";
})(ComponentMediaQuery || (ComponentMediaQuery = {}));
/**
 * BaseComponent extends LitElement adding mgt specific features to all components
 *
 * @export  MgtBaseComponent
 * @abstract
 * @class MgtBaseComponent
 * @extends {LitElement}
 */
export class MgtBaseComponent extends LitElement {
    /**
     * Gets the ComponentMediaQuery of the component
     *
     * @readonly
     * @type {MgtElement.ComponentMediaQuery}
     * @memberof MgtBaseComponent
     */
    get mediaQuery() {
        if (this.offsetWidth < 768) {
            return ComponentMediaQuery.mobile;
        }
        else if (this.offsetWidth < 1200) {
            return ComponentMediaQuery.tablet;
        }
        else {
            return ComponentMediaQuery.desktop;
        }
    }
    /**
     * A flag to check if the component is loading data state.
     *
     * @protected
     * @memberof MgtBaseComponent
     */
    get isLoadingState() {
        return this._isLoadingState;
    }
    /**
     * A flag to check if the component has updated once.
     *
     * @readonly
     * @protected
     * @type {boolean}
     * @memberof MgtBaseComponent
     */
    get isFirstUpdated() {
        return this._isFirstUpdated;
    }
    /**
     * returns component strings
     *
     * @readonly
     * @protected
     * @memberof MgtBaseComponent
     */
    get strings() {
        return {};
    }
    constructor() {
        super();
        /**
         * Gets or sets the direction of the component
         *
         * @protected
         * @memberof MgtBaseComponent
         */
        this.direction = 'ltr';
        /**
         * determines if login component is in loading state
         * @type {boolean}
         */
        this._isLoadingState = false;
        this._isFirstUpdated = false;
        this.handleLocalizationChanged = this.handleLocalizationChanged.bind(this);
        this.handleDirectionChanged = this.handleDirectionChanged.bind(this);
        this.handleProviderUpdates = this.handleProviderUpdates.bind(this);
        this.handleActiveAccountUpdates = this.handleActiveAccountUpdates.bind(this);
        this.handleDirectionChanged();
        this.handleLocalizationChanged();
    }
    /**
     * Invoked each time the custom element is appended into a document-connected element
     *
     * @memberof MgtBaseComponent
     */
    connectedCallback() {
        super.connectedCallback();
        LocalizationHelper.onStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.onDirectionUpdated(this.handleDirectionChanged);
    }
    /**
     * Invoked each time the custom element is removed from a document-connected element
     *
     * @memberof MgtBaseComponent
     */
    disconnectedCallback() {
        super.disconnectedCallback();
        LocalizationHelper.removeOnStringsUpdated(this.handleLocalizationChanged);
        LocalizationHelper.removeOnDirectionUpdated(this.handleDirectionChanged);
        Providers.removeProviderUpdatedListener(this.handleProviderUpdates);
        Providers.removeActiveAccountChangedListener(this.handleActiveAccountUpdates);
    }
    /**
     * Invoked when the element is first updated. Implement to perform one time
     * work on the element after update.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * @param _changedProperties Map of changed properties with old values
     */
    firstUpdated(changedProperties) {
        super.firstUpdated(changedProperties);
        this._isFirstUpdated = true;
        Providers.onProviderUpdated(this.handleProviderUpdates);
        Providers.onActiveAccountChanged(this.handleActiveAccountUpdates);
        this.requestStateUpdate();
    }
    /**
     * load state into the component.
     * Override this function to provide additional loading logic.
     */
    loadState() {
        return Promise.resolve();
    }
    clearState() { }
    /**
     * helps facilitate creation of events across components
     *
     * @protected
     * @param {string} eventName
     * @param {*} [detail]
     * @param {boolean} [bubbles=false]
     * @param {boolean} [cancelable=false]
     * @return {*}  {boolean}
     * @memberof MgtBaseComponent
     */
    fireCustomEvent(eventName, detail, bubbles = false, cancelable = false) {
        const event = new CustomEvent(eventName, {
            bubbles,
            cancelable,
            detail
        });
        return this.dispatchEvent(event);
    }
    /**
     * Invoked whenever the element is updated. Implement to perform
     * post-updating tasks via DOM APIs, for example, focusing an element.
     *
     * Setting properties inside this method will trigger the element to update
     * again after this update cycle completes.
     *
     * * @param changedProperties Map of changed properties with old values
     */
    updated(changedProperties) {
        super.updated(changedProperties);
        const event = new CustomEvent('updated', {
            bubbles: true,
            cancelable: true
        });
        this.dispatchEvent(event);
    }
    /**
     * Request to reload the state.
     * Use reload instead of load to ensure loading events are fired.
     *
     * @protected
     * @memberof MgtBaseComponent
     */
    requestStateUpdate(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // the component is still bootstraping - wait until first updated
            if (!this._isFirstUpdated) {
                return;
            }
            // Wait for the current load promise to complete (unless forced).
            if (this.isLoadingState && !force) {
                yield this._currentLoadStatePromise;
            }
            const provider = Providers.globalProvider;
            if (!provider) {
                return Promise.resolve();
            }
            if (provider.state === ProviderState.SignedOut) {
                // Signed out, clear the component state
                this.clearState();
                return;
            }
            else if (provider.state === ProviderState.Loading) {
                // The provider state is indeterminate. Do nothing.
                return Promise.resolve();
            }
            else {
                // Signed in, load the internal component state
                const loadStatePromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        this.setLoadingState(true);
                        this.fireCustomEvent('loadingInitiated');
                        yield this.loadState();
                        this.setLoadingState(false);
                        this.fireCustomEvent('loadingCompleted');
                        resolve();
                    }
                    catch (e) {
                        // Loading failed. Clear any partially set data.
                        this.clearState();
                        this.setLoadingState(false);
                        this.fireCustomEvent('loadingFailed');
                        reject(e);
                    }
                    // Return the load state promise.
                    // If loading + forced, chain the promises.
                    // This is to account for the lack of a cancellation token concept.
                    return (this._currentLoadStatePromise =
                        this.isLoadingState && !!this._currentLoadStatePromise && force
                            ? this._currentLoadStatePromise.then(() => loadStatePromise)
                            : loadStatePromise);
                }));
            }
        });
    }
    setLoadingState(value) {
        if (this._isLoadingState === value) {
            return;
        }
        this._isLoadingState = value;
        this.requestUpdate('isLoadingState');
    }
    handleProviderUpdates() {
        this.requestStateUpdate();
    }
    handleActiveAccountUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clearState();
            this.requestStateUpdate();
        });
    }
    handleLocalizationChanged() {
        LocalizationHelper.updateStringsForTag(this.tagName, this.strings);
        this.requestUpdate();
    }
    handleDirectionChanged() {
        this.direction = LocalizationHelper.getDocumentDirection();
    }
}
__decorate([
    internalProperty(),
    __metadata("design:type", Object)
], MgtBaseComponent.prototype, "direction", void 0);
//# sourceMappingURL=baseComponent.js.map