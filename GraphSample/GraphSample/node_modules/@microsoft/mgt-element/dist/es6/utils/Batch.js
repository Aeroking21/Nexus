/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BatchResponse } from '../IBatch';
import { BatchRequestContent } from '@microsoft/microsoft-graph-client';
import { delay } from '../utils';
import { prepScopes } from './GraphHelpers';
/**
 * Represents a request to be executed in a batch
 *
 * @class BatchRequest
 */
export class BatchRequest {
    constructor(index, id, resource, method) {
        if (resource.charAt(0) !== '/') {
            resource = '/' + resource;
        }
        this.resource = resource;
        this.method = method;
        this.index = index;
        this.id = id;
    }
}
/**
 * Method to reduce repetitive requests to the Graph
 *
 * @export
 * @class Batch
 */
// tslint:disable-next-line: max-classes-per-file
export class Batch {
    constructor(graph) {
        this.graph = graph;
        this.allRequests = [];
        this.requestsQueue = [];
        this.scopes = [];
        this.nextIndex = 0;
        this.retryAfter = 0;
    }
    /**
     * Get whether there are requests that have not been executed
     *
     * @readonly
     * @memberof Batch
     */
    get hasRequests() {
        return this.requestsQueue.length > 0;
    }
    /**
     * sets new request and scopes
     *
     * @param {string} id
     * @param {string} resource
     * @param {string[]} [scopes]
     * @memberof Batch
     */
    get(id, resource, scopes, headers) {
        const index = this.nextIndex++;
        const request = new BatchRequest(index, id, resource, 'GET');
        request.headers = headers;
        this.allRequests.push(request);
        this.requestsQueue.push(index);
        if (scopes) {
            this.scopes = this.scopes.concat(scopes);
        }
    }
    /**
     * Execute the next set of requests.
     * This will execute up to 20 requests at a time
     *
     * @returns {Promise<Map<string, BatchResponse>>}
     * @memberof Batch
     */
    executeNext() {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = new Map();
            if (this.retryAfter) {
                yield delay(this.retryAfter * 1000);
                this.retryAfter = 0;
            }
            if (!this.hasRequests) {
                return responses;
            }
            // batch can support up to 20 requests
            const nextBatch = this.requestsQueue.splice(0, 20);
            const batchRequestContent = new BatchRequestContent();
            for (const request of nextBatch.map(i => this.allRequests[i])) {
                batchRequestContent.addRequest({
                    id: request.index.toString(),
                    request: new Request(Batch.baseUrl + request.resource, {
                        method: request.method,
                        headers: request.headers
                    })
                });
            }
            const middlewareOptions = this.scopes.length ? prepScopes(...this.scopes) : [];
            const batchRequest = this.graph.api('$batch').middlewareOptions(middlewareOptions);
            const batchRequestBody = yield batchRequestContent.getContent();
            const batchResponse = yield batchRequest.post(batchRequestBody);
            for (const r of batchResponse.responses) {
                const response = new BatchResponse();
                const request = this.allRequests[r.id];
                response.id = request.id;
                response.index = request.index;
                response.headers = r.headers;
                if (r.status !== 200) {
                    if (r.status === 429) {
                        // this request was throttled
                        // add request back to queue and set retry wait time
                        this.requestsQueue.unshift(r.id);
                        this.retryAfter = Math.max(this.retryAfter, parseInt(r.headers['Retry-After'], 10) || 1);
                    }
                    continue;
                }
                else if (r.headers['Content-Type'].includes('image/jpeg')) {
                    response.content = 'data:image/jpeg;base64,' + r.body;
                }
                else if (r.headers['Content-Type'].includes('image/pjpeg')) {
                    response.content = 'data:image/pjpeg;base64,' + r.body;
                }
                else if (r.headers['Content-Type'].includes('image/png')) {
                    response.content = 'data:image/png;base64,' + r.body;
                }
                else {
                    response.content = r.body;
                }
                responses.set(request.id, response);
            }
            return responses;
        });
    }
    /**
     * Execute all requests, up to 20 at a time until
     * all requests have been executed
     *
     * @returns {Promise<Map<string, BatchResponse>>}
     * @memberof Batch
     */
    executeAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const responses = new Map();
            while (this.hasRequests) {
                const r = yield this.executeNext();
                for (const [key, value] of r) {
                    responses.set(key, value);
                }
            }
            return responses;
        });
    }
}
// this doesn't really mater what it is as long as it's a root base url
// otherwise a Request assumes the current path and that could change the relative path
Batch.baseUrl = 'https://graph.microsoft.com';
//# sourceMappingURL=Batch.js.map