/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { openDB } from 'idb';
import { Providers } from '../providers/Providers';
import { ProviderState } from '../providers/IProvider';
/**
 * class in charge of managing all the caches and their stores
 *
 * @export
 * @class CacheService
 */
// tslint:disable-next-line: max-classes-per-file
export class CacheService {
    /**
     *  Looks for existing cache, otherwise creates a new one
     *
     * @static
     * @template T
     * @param {CacheSchema} schema
     * @param {string} storeName
     * @returns {CacheStore<T>}
     * @memberof CacheService
     */
    static getCache(schema, storeName) {
        const key = `${schema.name}/${storeName}`;
        if (!this.isInitialized) {
            this.init();
        }
        if (!this.cacheStore.has(storeName)) {
            this.cacheStore.set(key, new CacheStore(schema, storeName));
        }
        return this.cacheStore.get(key);
    }
    /**
     * Clears all the stores within the cache
     */
    static clearCaches() {
        this.cacheStore.forEach(x => indexedDB.deleteDatabase(x.getDBName()));
    }
    /**
     * returns the cacheconfig object
     *
     * @readonly
     * @static
     * @type {CacheConfig}
     * @memberof CacheService
     */
    static get config() {
        return this.cacheConfig;
    }
    /**
     * Checks for current sign in state and see if it has changed from signed-in to signed out
     *
     *
     * @private
     * @static
     * @memberof CacheService
     */
    static init() {
        let previousState;
        if (Providers.globalProvider) {
            previousState = Providers.globalProvider.state;
        }
        Providers.onProviderUpdated(() => {
            if (previousState === ProviderState.SignedIn && Providers.globalProvider.state === ProviderState.SignedOut) {
                this.clearCaches();
            }
            previousState = Providers.globalProvider.state;
        });
        this.isInitialized = true;
    }
}
CacheService.cacheStore = new Map();
CacheService.isInitialized = false;
CacheService.cacheConfig = {
    defaultInvalidationPeriod: 3600000,
    groups: {
        invalidationPeriod: null,
        isEnabled: true
    },
    isEnabled: true,
    people: {
        invalidationPeriod: null,
        isEnabled: true
    },
    photos: {
        invalidationPeriod: null,
        isEnabled: true
    },
    presence: {
        invalidationPeriod: 300000,
        isEnabled: true
    },
    users: {
        invalidationPeriod: null,
        isEnabled: true
    },
    response: {
        invalidationPeriod: null,
        isEnabled: true
    },
    files: {
        invalidationPeriod: null,
        isEnabled: true
    },
    fileLists: {
        invalidationPeriod: null,
        isEnabled: true
    }
};
/**
 * Represents a store in the cache
 *
 * @class CacheStore
 * @template T
 */
// tslint:disable-next-line: max-classes-per-file
export class CacheStore {
    constructor(schema, store) {
        if (!(store in schema.stores)) {
            throw Error('"store" must be defined in the "schema"');
        }
        this.schema = schema;
        this.store = store;
    }
    /**
     * gets value from cache for the given key
     *
     * @param {string} key
     * @returns {Promise<T>}
     * @memberof Cache
     */
    getValue(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return null;
            }
            try {
                return (yield this.getDb()).get(this.store, key);
            }
            catch (e) {
                return null;
            }
        });
    }
    /**
     * inserts value into cache for the given key
     *
     * @param {string} key
     * @param {T} item
     * @returns
     * @memberof Cache
     */
    putValue(key, item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return;
            }
            try {
                yield (yield this.getDb()).put(this.store, Object.assign(Object.assign({}, item), { timeCached: Date.now() }), key);
            }
            catch (e) {
                return;
            }
        });
    }
    /**
     * Clears the store of all stored values
     *
     * @returns
     * @memberof Cache
     */
    clearStore() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return;
            }
            try {
                (yield this.getDb()).clear(this.store);
            }
            catch (e) {
                return;
            }
        });
    }
    /**
     * Returns the name of the parent DB that the cache store belongs to
     */
    getDBName() {
        return `mgt-${this.schema.name}`;
    }
    getDb() {
        return openDB(this.getDBName(), this.schema.version, {
            upgrade: (db, oldVersion, newVersion, transaction) => {
                for (const storeName in this.schema.stores) {
                    if (this.schema.stores.hasOwnProperty(storeName)) {
                        db.objectStoreNames.contains(storeName) || db.createObjectStore(storeName);
                    }
                }
            }
        });
    }
}
//# sourceMappingURL=Cache.js.map