{"version":3,"file":"equals.js","sourceRoot":"src/","sources":["utils/equals.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH;;;;;;GAMG;AACH,MAAM,UAAU,MAAM,CAAC,EAAO,EAAE,EAAO;IACrC,OAAO,cAAc,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AAC3C,CAAC;AAED;;;;;;GAMG;AACH,SAAS,cAAc,CAAC,EAAO,EAAE,EAAO,EAAE,IAAiB;IACzD,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnD,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnD,IAAI,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,iBAAiB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;QACzE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACb,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;YAClB,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;gBACvC,OAAO,KAAK,CAAC;aACd;SACF;QACD,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;YAClB,IAAI,CAAC,EAAE,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE;gBACzB,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;KACb;IACD,IAAI,OAAO,KAAK,OAAO,IAAI,OAAO,KAAK,gBAAgB,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;QACxE,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACb,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM,EAAE;YAC3B,OAAO,KAAK,CAAC;SACd;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;gBACvC,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;KACb;IACD,+EAA+E;IAC/E,OAAO,EAAE,KAAK,EAAE,CAAC;AACnB,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,UAAU,cAAc,CAAI,IAAS,EAAE,IAAS;IACpD,IAAI,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,IAAI,CAAC;KACb;IAED,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;QAClB,OAAO,KAAK,CAAC;KACd;IAED,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,OAAO,IAAI,CAAC;KACb;IAED,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;IAE9B,KAAK,MAAM,CAAC,IAAI,IAAI,EAAE;QACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACnB,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * Crude implementation of equivalence between the two specified arguments.\n *\n * The primary intent of this function is for comparing data contexts, which\n * are expected to be object literals with potentially nested structures and\n * where leaf values are primitives.\n */\nexport function equals(o1: any, o2: any) {\n  return equalsInternal(o1, o2, new Set());\n}\n\n/**\n * Not exposed as it would undesirably leak implementation detail (`refs` argument).\n *\n * The `refs` argument is used to avoid infinite recursion due to circular references.\n *\n * @see equals\n */\nfunction equalsInternal(o1: any, o2: any, refs: Set<object>) {\n  const o1Label = Object.prototype.toString.call(o1);\n  const o2Label = Object.prototype.toString.call(o2);\n  if (o1Label === o2Label && o1Label === '[object Object]' && !refs.has(o1)) {\n    refs.add(o1);\n    for (const k in o1) {\n      if (!equalsInternal(o1[k], o2[k], refs)) {\n        return false;\n      }\n    }\n    for (const k in o2) {\n      if (!o1.hasOwnProperty(k)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (o1Label === o2Label && o1Label === '[object Array]' && !refs.has(o1)) {\n    refs.add(o1);\n    if (o1.length !== o2.length) {\n      return false;\n    }\n    for (let i = 0; i < o1.length; i++) {\n      if (!equalsInternal(o1[i], o2[i], refs)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Everything else requires strict equality (e.g. primitives, functions, dates)\n  return o1 === o2;\n}\n\n/**\n * Compares two arrays if the elements are equals\n * Should be used for arrays of primitive types\n *\n * @export\n * @template T the type of the elements in the array (should be primitive)\n * @param {T[]} arr1\n * @param {T[]} arr2\n * @returns true if both arrays contain the same items or if both arrays are null or empty\n */\nexport function arraysAreEqual<T>(arr1: T[], arr2: T[]) {\n  if (arr1 === arr2) {\n    return true;\n  }\n\n  if (!arr1 || !arr2) {\n    return false;\n  }\n\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  if (arr1.length === 0) {\n    return true;\n  }\n\n  const setArr1 = new Set(arr1);\n\n  for (const i of arr2) {\n    if (!setArr1.has(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"]}